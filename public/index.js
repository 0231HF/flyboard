'use strict';var widgetTypes = [    {        type: 1,        label: '折线图'    },    {        type: 2,        label: '饼图'    },    {        type: 3,        label: '环形图'    },    {        type: 4,        label: '数字'    },    {        type: 5,        label: '柱形图'    }];var indexApp = angular.module('indexApp', [    'ngRoute',    'services',    'ngAnimate',    'ui.bootstrap']);var gridLayer = {    'rows': [        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        }    ]};indexApp.value('gridLayerConfig', {number: 12});indexApp.config(['$routeProvider',function($routeProvider){    $routeProvider.        when('/dashboards/:id?', {            templateUrl:'/public/src/index.html',            controller: 'IndexCtrl'        }).        when('/dashboards/:id/edit', {            templateUrl: '/public/src/edit_layout.html',            controller: 'editLayoutCtrl'        }).        otherwise({            redirectTo: '/dashboards'        });}]);function isScopeDestroyed(scope){    while(scope){        if(scope.$$destroyed){            return true;        }        scope = scope.$parent;    }    return false;}function range(n, initValue){    var ret = [];    for(var i=0; i<n; i++){        ret[i] = initValue !== undefined ? initValue : 0;    }    return ret;}indexApp.controller('SlideCtrl', ['$scope', '$route', '$routeParams', '$window', '$q', '$location', '$interval', '$timeout', 'Dashboard',    function($scope, $route, $routeParams, $window, $q, $location, $interval, $timeout, Dashboard) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = {};        $scope.$on('$routeChangeSuccess', function () {            //if editLayoutCtrl, no slide            if($route.current.$$route.controller === 'editLayoutCtrl'){                $($window).off('mousemove', resetCheck);                stopCheck();            }            if ($routeParams.id) {                Dashboard.get({                    id: $routeParams.id                }).$promise.then(function (dashbaord) {                    $scope.dashboard = dashbaord;                });            } else {                $scope.dashboards.$promise.then(function (dashboards) {                    $scope.dashboard = dashboards[0] || null;                });            }        });        var SLIDE_INTERVAL_TIME = 600000;        var PHASE_DELAY_TIME = 1000 + 1500;        var PHASE_COUNT = 10;        //slide        $scope.slideMode = false;        //slide        function doSlide(){            var currentDashboardIdx = null;            $scope.dashboards.some(function (dashboard, idx) {                if (dashboard.id === $scope.dashboard.id) {                    currentDashboardIdx = idx;                    return true;                }            });            currentDashboardIdx = (currentDashboardIdx + 1) % $scope.dashboards.length;            var newUrl = '/dashboards/' + $scope.dashboards[currentDashboardIdx].id;            $location.path(newUrl);            stopPhaseTimer();            startPhaseDelayTimer();        }        // delay phase run        var phaseDelayTimer = null;        function startPhaseDelayTimer() {            stopPhaseDelayTimer();            phaseDelayTimer = $timeout(startPhaseTimer, PHASE_DELAY_TIME);        }        function stopPhaseDelayTimer() {            if (phaseDelayTimer !== null) {                $timeout.cancel(phaseDelayTimer);                phaseDelayTimer = null;            }        }        //timer for next slide        $scope.phase = 0;        // phase counter        var phaseTimer = null;        //timer for next slide        function startPhaseTimer(){            stopPhaseTimer();            $scope.phase = 0;            phaseTimer = $interval(function () {                $scope.phase += 1;            }, (SLIDE_INTERVAL_TIME - PHASE_DELAY_TIME) / PHASE_COUNT);        }        function stopPhaseTimer() {            if (phaseTimer) {                $interval.cancel(phaseTimer);                phaseTimer = null;            }            $scope.phase = -1;        }        // control dashboard slide interval        var slideTimer = null;        //check if go into auto slide Mode        function startSlide(){            stopSlide();            $scope.slideMode = true;            slideTimer = $interval(doSlide, SLIDE_INTERVAL_TIME);            doSlide();  //call once        }        function stopSlide() {            if (slideTimer) {                $interval.cancel(slideTimer);                slideTimer = null;            }            $scope.slideMode = false;        }        // check away from keyboard        var checkTimer = null;        function startCheck() {            stopCheck();            checkTimer = $timeout(startSlide, SLIDE_INTERVAL_TIME);        }        function stopCheck() {            if (checkTimer) {                $timeout.cancel(checkTimer);                checkTimer = null;            }        }        function resetCheck() {            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();            startCheck();        }        startCheck();        $($window).on('mousemove', resetCheck);        $scope.$on('$destroy', function(){            $($window).off('mousemove', resetCheck);            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();        });    }]);indexApp.controller('NavCtrl', ['$scope', '$route', '$routeParams','$q', '$location', '$window', 'Dashboard',    function($scope, $route, $routeParams, $q, $location, $window, Dashboard){        $scope.editLayoutMode = false;        $scope.dashboards = Dashboard.query();        $q.when($scope.dashboards).then(function(dashboards){            $scope.dashboards = dashboards || [];            function init(evt){                // ignore element resize event                if (evt.target !== undefined) {                    return;                }                $scope.editLayoutMode = $route.current.$$route.controller === 'editLayoutCtrl';                var dashboardId = $routeParams.id ? $routeParams.id : (($scope.dashboards && $scope.dashboards.length > 0) ? $scope.dashboards[0].id: null);                if(dashboardId !== null){                    $scope.widgets = Dashboard.get({                        id: dashboardId                    }).$promise.then(function(dashboard){                        $scope.dashboard = dashboard;                    });                }            }            angular.element($window).bind('resize', init);            $scope.$on('$routeChangeSuccess', init);            $scope.enterEditLayoutMode = function(){                var newUrl = '/dashboards/' + $scope.dashboard.id + '/edit';                $location.path(newUrl);            };        });    }]);indexApp.controller('IndexCtrl', ['$scope', '$window', '$routeParams', '$location', '$interval', 'Dashboard', 'Widget', '$q',    function($scope, $window, $routeParams, $location, $interval, Dashboard, Widget, $q) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = $routeParams.id ?            Dashboard.get({                id: $routeParams.id            }).$promise.then(function(dashboard){                return dashboard || null;            })            : $scope.dashboards.$promise.then(function (dashboards) {                return dashboards[0] || null;            });        $scope.widgets = $q.when($scope.dashboard).then(function (dashboard) {            if (dashboard === null) {                return [];            }            $scope.dashboard = dashboard;            if(!$scope.dashboard.config || !$scope.dashboard.config.layout){                return ;            }            $scope.layout = $scope.dashboard.config.layout.map(function(widgetLayout){                return {                    id: widgetLayout.id,                    x: widgetLayout.first_grid[0],                    y: widgetLayout.first_grid[1],                    w: widgetLayout.last_grid[1] - widgetLayout.first_grid[1] + 1,                    h: widgetLayout.last_grid[0] - widgetLayout.first_grid[0] + 1                };            });            return Widget.query({                dashboardid: dashboard.id            }).$promise.then(function(widgets){                return widgets;            });        });        $q.when($scope.widgets).then(function(widgets){            widgets = widgets || [];            $scope.widgets = widgets.reduce(function (memo, curr) {                memo[curr.id] = curr;                return memo;            }, {});        });    }]);indexApp.controller('editLayoutCtrl', ['$scope', '$window', '$routeParams', '$location', '$interval', 'Dashboard', 'Widget', '$q',    function($scope, $window, $routeParams, $location, $interval, Dashboard, Widget, $q) {        $scope.gridLayer = gridLayer;        $scope.dashboards = Dashboard.query();        $scope.widgetControllers = [];        $scope.addedControllers = [];        $scope.gridLayerStatus = [];        $scope.conflictWidgetControllers = [];        $scope.dashboard = Dashboard.get({            id: $routeParams.id        }).$promise.then(function(dashboard){            return dashboard || null;        });        function matchSameSegment(seg, cmpRow){            var ret = null;            cmpRow.some(function(cmpSeg, idx){                if(cmpSeg[0] > seg[0]){                    return true;                }                if(cmpSeg[0] === seg[0] && cmpSeg[1] === seg[1]){                    ret = idx;                    return true;                }            });            return ret;        }        // scan unused grid segmemt of each row        function scanGrids(grids){            var rowCount = $scope.gridLayerStatus.length;            var colCount = $scope.gridLayerStatus[0].length;            var ret = [];            for(var i = 0; i < rowCount; i++){                ret[i] = [];                var start = null, end = null;                for(var j = 0; j < colCount; j++){                    if(!grids[i][j] && start === null){                        start = j;                    }                    else if(grids[i][j] && start !== null){                        end = j-1;                        ret[i].push([start, end]);                        start = null;                        end = null;                    }                }                if(start !== null){                    ret[i].push([start, colCount - 1]);                }            }            return ret;        }        //calculate controllers for widgets        function calculateWidgetControllers() {            return $scope.dashboard.config.layout.map(function (widget) {                return {                    id: widget.id,                    x: widget.first_grid[0],                    y: widget.first_grid[1],                    w: widget.last_grid[1] - widget.first_grid[1] + 1,                    h: widget.last_grid[0] - widget.first_grid[0] + 1                };            });        }        //split unused grid to controllers        function calculateValidControllers() {            if(!$scope.gridLayerStatus || $scope.gridLayerStatus.length <= 0 || $scope.gridLayerStatus[0].length <= 0){                return [];            }            var validGridSegments = scanGrids($scope.gridLayerStatus);            var result =[];            validGridSegments.forEach(function(row, rowIdx){                row.forEach(function(seg){                    var w = seg[1] - seg[0] + 1;                    var h = 1;  //at least 1 row                    validGridSegments.some(function(cmpRow, cmpRowIdx){                        if(cmpRowIdx <= rowIdx){                            return false;                        }                        var ret = matchSameSegment(seg, cmpRow);                        if(ret !== null){                            h = cmpRowIdx - rowIdx + 1;                            validGridSegments[cmpRowIdx].splice(ret, 1);                        }                        else {                            return true;                        }                    });                    result.push({                        id: null,                        x: rowIdx,                        y: seg[0],                        w: w,                        h: h                    });                });                validGridSegments[rowIdx] = [];            });            return result;        }        $scope.widgets = $q.when($scope.dashboard).then(function (dashboard) {            if (dashboard === null) {                return [];            }            $scope.dashboard = dashboard;            if(!$scope.dashboard.config || !$scope.dashboard.config.layout){                return ;            }            $scope.layout = $scope.dashboard.config.layout.map(function(widgetLayout){                return {                    id: widgetLayout.id,                    x: widgetLayout.first_grid[0],                    y: widgetLayout.first_grid[1],                    w: widgetLayout.last_grid[1] - widgetLayout.first_grid[1] + 1,                    h: widgetLayout.last_grid[0] - widgetLayout.first_grid[0] + 1                };            });            //init grids status            $scope.gridLayerStatus = range(12, false).map(range.bind(null, 12, false));            $scope.dashboard.config.layout.forEach(function(widget){                for(var i = widget.first_grid[0]; i <= widget.last_grid[0]; i++){                    for(var j = widget.first_grid[1]; j <= widget.last_grid[1]; j++){                        $scope.gridLayerStatus[i][j] = true;                    }                }            });            $scope.widgetControllers = calculateWidgetControllers();            $scope.addedControllers = calculateValidControllers();            //request widgets info            return Widget.query({                dashboardid: dashboard.id            }).$promise.then(function(widgets){                return widgets;            });        });        $q.when($scope.widgets).then(function(widgets){            widgets = widgets || [];            $scope.widgets = widgets.reduce(function (memo, curr) {                memo[curr.id] = curr;                return memo;            }, {});        });        /**************** public funcs *******************/        function conflictTest (newController, oldController){            for(var i = newController.x; i < newController.x + newController.h; i++){                for(var j = newController.y; j < newController.y + newController.w; j++){                    var gridObj = {                        x: i,                        y: j                    };                    if(!isValidGrid(gridObj, $scope.gridLayerStatus) && !isGridBelongToController(gridObj, oldController)) {                        return true;                    }                }            }            return false;        }        function resizeAll(newController, oldController){            //update gridLayerStatus            for(var i = oldController.x; i < oldController.x + oldController.h; i++){                for(var j = oldController.y; j < oldController.y + oldController.w; j++){                    $scope.gridLayerStatus[i][j] = false;                }            }            for(var m = newController.x; m < newController.x + newController.h; m++){                for(var n = newController.y; n < newController.y + newController.w; n++){                    $scope.gridLayerStatus[m][n] = true;                }            }            angular.element.each(newController, function(key){                oldController[key] = newController[key];            });            //resize controllers            $scope.addedControllers = calculateValidControllers();            //resize widgets            $scope.layout.some(function(widgetLayout){                if(widgetLayout.id === oldController.id) {                    angular.element.each(oldController, function (key) {                        widgetLayout[key] = oldController[key];                    });                }            });            $scope.$apply();            $scope.$broadcast('layoutchange');        }        /************************ resize ***********************/        //check if grids[x][y] is a valid grid        function isValidGrid(gridObj, grids) {            return grids[gridObj.x][gridObj.y] === false;        }        //check if grids[x][y] is controller's grid        function isGridBelongToController (gridObj, controller) {            var x = gridObj.x;            var y = gridObj.y;            return ( x >= controller.x && x < (controller.x + controller.h) ) && ( y >= controller.y && y < ( controller.y + controller.w ) );        }        $scope.adjustResize = function(newController, oldController) {            //if no change happen            if(newController.x === oldController.x && newController.y === oldController.y && newController.w === oldController.w && newController.h === oldController.h){                return ;            }            //if width < 1 or height < 1            if(newController.w === 0 || newController.h === 0){                return ;            }            //if conflict            if(conflictTest(newController, oldController)) {                return;            }            resizeAll(newController, oldController);        };        /*************** drag ****************/        $scope.adjustDrag = function(newController, oldController){            //if no change happen            if(newController.x === oldController.x && newController.y === oldController.y && newController.w === oldController.w && newController.h === oldController.h){                return ;            }            if(conflictTest(newController, oldController)){                $scope.conflictWidgetControllers.push(oldController.id);                return ;            }            else{                $scope.conflictWidgetControllers = [];                resizeAll(newController, oldController);            }        };        $scope.stopDrag = function(){            $scope.conflictWidgetControllers = [];        };        //save edit        $scope.saveLayoutEdit = function() {            $scope.dashboard.config.layout = $scope.layout.map(function(widgetLayout){                return {                    id: widgetLayout.id,                    first_grid: [widgetLayout.x, widgetLayout.y],                    last_grid: [widgetLayout.x + widgetLayout.h - 1, widgetLayout.y + widgetLayout.w - 1]                };            });            Dashboard.update({                id: $scope.dashboard.id            }, $scope.dashboard).$promise.then(function(dashboard){                var newUrl = '/dashboards/' + dashboard.id;                $location.path(newUrl);            });        };        $scope.cancelLayoutEdit = function() {            var newUrl = '/dashboards/' + $scope.dashboard.id;            $location.path(newUrl);        };    }]);indexApp.controller('newWidgetModalCtrl', ['$scope', '$modal',    function($scope, $modal){        var $outerScope = $scope;        var newWidgetModalInstanceCtrl = ['$scope', 'Widget', 'DataSource', 'Dashboard', '$modalInstance', 'dashboard', 'controller',            function ($scope, Widget, DataSource, Dashboard, $modalInstance, dashboard, controller) {                $scope.dashboard = dashboard;                $scope.newWidgetIds = [];                $scope.widgetTypes = widgetTypes;                $scope.addedDataInfo = {};                $scope.widget = {                    dashboard_id: dashboard.id,                    config: {}                };                DataSource.query().$promise.then(function (dataSources) {                    $scope.dataSources = dataSources;                    $scope.dataSourceInfos = $scope.dataSources.reduce(function (memo, curr) {                        memo[curr.id] = curr;                        return memo;                    }, {});                });                $scope.addDataInfo = function(){                    $scope.isAddDataInfo = true;                };                $scope.deleteDataInfo = function(dataInfo){                    var idx = $scope.widget.config.dataInfos.indexOf(dataInfo);                    if(idx === -1){                        return ;                    }                    $scope.widget.config.dataInfos.splice(idx, 1);                };                $scope.addOk = function(){                    if(!$scope.addedDataInfo.id){                        return ;                    }                    $scope.widget.config.dataInfos = $scope.widget.config.dataInfos || [];                    var idx = -1;                    $scope.widget.config.dataInfos.some(function(dataInfo, index){                        if(dataInfo.id === $scope.addedDataInfo.id){                            idx = index;                            return true;                        }                    });                    if(idx === -1){                        DataSource.get({                            id: $scope.addedDataInfo.id                        }).$promise.then(function(dataSource) {                            $scope.widget.config.dataInfos.push({                                id: dataSource.id                            });                        });                    }                    $scope.isAddDataInfo = false;                    $scope.addedDataInfo = {};                };                $scope.addCancel = function(){                    $scope.isAddDataInfo = false;                };                $scope.ok = function () {                    Widget.save({                        dashboardid: $scope.dashboard.id                    }, $scope.widget).$promise.then(function (widget) {                        $scope.newWidgetIds.push(widget.id);                        $outerScope.widgets[widget.id] = widget;                        //update dashboard                        $scope.dashboard.config = $scope.dashboard.config || {};                        $scope.dashboard.config.layout = $scope.dashboard.config.layout || [];                        $scope.dashboard.config.layout.push({                            id: widget.id,                            first_grid: [controller.x, controller.y],                            last_grid: [controller.x + controller.h - 1, controller.y + controller.w - 1]                        });                        //update layout view                        $outerScope.layout.push({                            id: widget.id,                            x: controller.x,                            y: controller.y,                            w: controller.w,                            h: controller.h                        });                        //update grids' status                        for(var i = controller.x; i < controller.x + controller.h; i++){                            for(var j = controller.y; j < controller.y + controller.w; j++){                                $outerScope.gridLayerStatus[i][j] = true;                            }                        }                        //delete controller from addedControllers                        var idx = $outerScope.addedControllers.indexOf(controller);                        $outerScope.addedControllers.splice(idx, 1);                        //add controller to widgetControllers                        controller.id = widget.id;                        $outerScope.widgetControllers.push(controller);                        $modalInstance.close();                    });                };                $scope.cancel = function () {                    $modalInstance.dismiss('cancel');                };            }        ];        $scope.open = function (controller) {            var newWidgetModalInstance = $modal.open({                templateUrl: '/public/src/include/widget_new_modal.html',                controller: newWidgetModalInstanceCtrl,                resolve: {                    dashboard: function () {                        return $scope.dashboard;                    },                    controller: function () {                        return controller;                    }                }            });        };    }]);indexApp.directive('resizeable', ['gridLayerConfig',    function(gridLayerConfig){        return {            restrict: 'A',            scope: {                resizableConfig: '=',                controller: '=',                adjustResize: '='            },            link: function($scope, $elem){                function resize(){                    var newW = Math.round($(this).width() / $(this).parents('.layer').width() * gridLayerConfig.number);                    var newH = Math.round($(this).height() / $(this).parents('.layer').height() * gridLayerConfig.number);                    var newController = {                        w: newW,                        h: newH,                        x: $scope.controller.x,                        y: $scope.controller.y                    };                    $scope.adjustResize(newController, $scope.controller);                }                function resizeStop(){                    //clear css style                    $(this).removeAttr('style');                }                $elem.resizable($scope.resizableConfig);                $elem.on('resize', resize);                $elem.on('resizestop', resizeStop);                $scope.$on('$destroy', function(){                    $elem.off('resize', resize);                    $elem.off('resizestop', resizeStop);                });            }        };    }]);indexApp.directive('draggable', ['gridLayerConfig',    function(gridLayerConfig){        return {            restrict: 'A',            scope: {                adjustDrag: '=',                stopDrag: '=',                controller: '='            },            link: function($scope, $elem){                var $dragElement = $elem.parent();                function drag() {                    var newX = Math.round($(this).offset().top / $(this).parents('.layer').height() * gridLayerConfig.number);                    var newY = Math.round($(this).offset().left / $(this).parents('.layer').width() * gridLayerConfig.number);                    var newController = {                        w: $scope.controller.w,                        h: $scope.controller.h,                        x: newX,                        y: newY                    };                    $scope.adjustDrag(newController, $scope.controller);                }                function dragStop () {                    $scope.stopDrag();                    //clear css style                    $(this).removeAttr('style');                }                $dragElement.draggable({                    handle:'div',                    cursor: 'move' ,                    scroll: false                });                $dragElement.on('drag', drag);                $dragElement.on('dragstop', dragStop);                $scope.$on('$destroy', function(){                    $dragElement.off('drag', drag);                    $dragElement.off('dragstop', dragStop);                });            }        };    }]);indexApp.service('widgetUrl', function () {    return function (widget) {        var href = '/stat#?dataSourceIds=';        if(!widget){            href = '/stat';            return href;        }        switch(widget.type){            case 1:            case 2:            case 5:                href += widget.config.dataInfos.map(function(dataInfo){                    return dataInfo.id;                }).join(',');                break;            case 3:            case 4:                href += widget.config.dataSourceId;                break;            default:                break;        }        return href;    };});indexApp.directive('widgetSpline', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function (widgetUrl, $q, DataSource, Record, $timeout) {        return {            restirct: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/spline.html',            replace: true,            link: function ($scope, $elem) {                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var latestRecordId = {};                var $container = $($elem).find('.content');                config.dataInfos = config.dataInfos || [];                //request data                var promises = config.dataInfos.map(function (dataInfo, index) {                    return DataSource.get({                        id: dataInfo.id                    }).$promise.then(function (dataSource) {                        return Record.query({                            id: dataInfo.id,                            limit: config.limit || 0                        }).$promise.then(function (resp) {                            var lineOpt = {};                            lineOpt.name = dataSource.name;                            index = index >= defaultColors.length ? (index % defaultColors.length) : index;                            lineOpt.color = defaultColors[index];                            lineOpt.data = [];                            resp = resp || [];                            latestRecordId[dataSource.name] = resp[0].id;                            resp.reverse().forEach(function (record) {                                lineOpt.data.push({                                    x: getTimeFromRecord(record),                                    y: record.value                                });                            });                            return lineOpt;                        });                    });                });                //draw chart                $q.all(promises).then(function (dataSeries) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            backgroundColor: '#2b2b2b',                            type: 'spline',                            animation: Highcharts.svg, // don't animate in old IE                            marginRight: 10,                            events: {                                load: function () {                                    var series = this.series;                                    // set up the updating of the chart each reloadInterval                                    intervalTimer = setInterval(function () {                                        config.dataInfos.forEach(function (dataInfo, idx) {                                            DataSource.get({                                                id: dataInfo.id                                            }).$promise.then(                                                function (dataSource) {                                                    Record.query({                                                        id: dataInfo.id,                                                        limit: config.limit || 0                                                    }).$promise.then(                                                        function (resp) {                                                            var flag = false;                                                            resp.reverse().filter(function (record) {                                                                if (record.id === latestRecordId[dataSource.name]) {                                                                    flag = true;                                                                    return false;                                                                }                                                                if (flag) {                                                                    series[idx].addPoint([getTimeFromRecord(record), record.value], true, true);                                                                }                                                            });                                                            latestRecordId[dataSource.name] = resp[resp.length - 1].id;                                                            $scope.updatedTime = formatDate(new Date ());                                                        });                                                });                                        });                                    }, config.reloadInterval);                                }                            }                        },                        title: {                            text: ''                        },                        xAxis: {                            type: 'datetime',                            tickPixelInterval: 150,                            lineColor: 'rgb(102, 108, 103)'                        },                        yAxis: {                            title: null,                            gridLineColor: null,                            plotLines: null,                            min: ( config.minThreshold !== undefined && config.minThreshold >= 0 ) ? config.minThreshold : null,                            max: ( config.maxThreshold !== undefined && config.maxThreshold >= 0 ) ? config.maxThreshold : null,                            startOnTick: false,                            endOnTick: false                        },                        tooltip: {                            crosshairs: true,                            shared: true                        },                        legend: {                            layout: 'vertical',                            align: 'left',                            verticalAlign: 'top',                            y: 0,                            floating: true,                            borderWidth: 0,                            itemStyle: {                                color: 'lightgray'                            }                        },                        exporting: {                            enabled: false                        },                        series: dataSeries,                        plotOptions: {                            spline: {                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    color: 'lightgray',                                    formatter: function () {                                        if (this.point.x === this.series.data[this.series.data.length - 1].x) {                                            return this.y;                                        } else {                                            return null;                                        }                                    }                                }                            }                        }                    });                    $scope.updatedTime = formatDate(new Date ());                    function resizeWidget(){                       chart.reflow();                    }                    var cleanUpFuncs = [];                    cleanUpFuncs.push($scope.$on('layoutchange', resizeWidget));                    $scope.$on('$destroy', function(){                        clearInterval(intervalTimer);                        $timeout(function () {                        if(chart) {                           chart.destroy();                        }                        }, 5000);                        cleanUpFuncs.forEach(function(cleanUpFunc){                            cleanUpFunc();                        });                    });                });            }        };    }]);indexApp.directive('widgetPie', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/pie.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $container = $($elem).find('.cf-pie');                var pId = $container.prop('id');                var config = $scope.widget.config;                config.dataInfos = config.dataInfos || [];                // Store chart information                cf_rPs[pId] = {};                //request data                var promises = config.dataInfos.map(function(dataInfo){                    return DataSource.get({                        id: dataInfo.id                    }).$promise.then(function (dataSource) {                        return Record.query({                            id: dataInfo.id,                            limit: 1                        }).$promise.then(function (resp) {                            if ((resp ? resp.length: 0) === 0) {                                return [dataSource.name, 0];                            }                            return [dataSource.name, resp[0].value];                        });                    });                });                //draw chart                $q.all(promises).then(function (data) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            plotBackgroundColor: null,                            plotBorderWidth: null,                            plotShadow: false,                            backgroundColor: 'rgba(0,0,0,0)',                            events: {                                load: function(){                                    var chart = this;                                    function reload(){                                        var promises = config.dataInfos.map(function(dataInfo){                                            return DataSource.get({                                                id: dataInfo.id                                            }).$promise.then(function(dataSource){                                                return Record.query({                                                    id: dataInfo.id,                                                    limit: 1                                                }).$promise.then(function(resp) {                                                    if ((resp ? resp.length : 0) === 0) {                                                        return [dataSource.name, 0];                                                    }                                                    return [dataSource.name, resp[0].value];                                                    }                                                );                                            });                                        });                                        $q.when(promises).then(function (result) {                                            chart.series[0].setData(result);                                            $scope.updatedTime = formatDate(new Date ());                                        });                                    }                                    intervalTimer = setInterval(reload, config.reloadInterval);                                }                            }                        },                        title:{                            text: ''                        },                        tooptip: {                            pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'                        },                        plotOptions: {                            pie: {                                allowPointSelect: true,                                cursor: 'pointer',                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    format: '<b>{point.name}</b>: {point.percentage:.1f} %',                                    color: 'lightgray',                                    style: {                                        color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black',                                        fontSize: '14px'                                    }                                }                            }                        },                        series: [{                            type: 'pie',                            name: config.name,                            data: data                        }]                    });                    $scope.updatedTime = formatDate(new Date ());                    function resizeWidget(){                        chart.reflow();                    }                    var cleanUpFuncs = [];                    cleanUpFuncs.push($scope.$on('layoutchange', resizeWidget));                    $scope.$on('$destroy', function() {                        clearInterval(intervalTimer);                        $timeout(function(){                            if (chart) {                                chart.destroy();                            }                        }, 5000);                        cleanUpFuncs.forEach(function(cleanUpFunc){                            cleanUpFunc();                        });                    });                });            }        };    }]);indexApp.directive('widgetDonut', [    'widgetUrl',    'Record',    '$timeout',    function(widgetUrl, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/donut.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $container = $elem.find('.cf-svp');                var $arrow = $elem.find('.change .arrow');                var $changeMetric = $elem.find('.change');                var $large = $changeMetric.find('.large');                var $small = $changeMetric.find('.small');                var config = $scope.widget.config;                $container.data('id', 'widget-' + $scope.widget.id);                var chartWrapper = rSVP($container);                //broadcast to call fitText once                $scope.$broadcast('fitdonut');                function reload(){                    var $container = $(this).find('.cf-svp');                    Record.query({                        id: config.dataSourceId,                        limit: 2                    }).$promise.then(function(records){                        //update change percentage                        var det;                        if(!records || records.length !== 2 || ( records.length === 2 && records[1] === 0 ) ) {                            det = 0;                        }                        else {                            det = ((records[0].value - records[1].value)/records[1].value) * 100;                        }                        if( det > 0 ){                            $arrow.removeClass('glyphicon-arrow-down');                            $arrow.addClass('glyphicon-arrow-up');                            $changeMetric.removeClass('m-green');                            $changeMetric.addClass('m-red');                        }                        else {                            $arrow.removeClass('glyphicon-arrow-up');                            $arrow.addClass('glyphicon-arrow-down');                            $changeMetric.removeClass('m-red');                            $changeMetric.addClass('m-green');                        }                        det = Math.abs(det).toFixed(2).toString().split('.');                        $large.text(det[0]);                        $small.text('.' + det[1] + '%');                        //update current value                        var chart = chartWrapper.chart;                        config.value = records[0].value;                        // Call EasyPieChart update function                        chart.update(config.value);                        // Update the data-percent so it redraws on resize properly                        $container.find('.chart').data('percent', config.value);                        // Update the UI metric                        $elem.find('.metric').html('' + config.value);                        $scope.updatedTime = formatDate(new Date ());                    });                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply(this);                function resizeWidget(){                    chartWrapper.generateChart();                }                var cleanUpFuncs = [];                cleanUpFuncs.push($scope.$on('layoutchange', resizeWidget));                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chartWrapper) {                            chartWrapper.destroy();                        }                    }, 5000);                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('widgetNumber', [    'widgetUrl',    '$q',    'Record',    function(widgetUrl, $q, Record){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/number.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $widget = $($elem);                var $metric = $widget.find('.metric');                var $metricSmall = $widget.find('.metric-small');                var $arrow = $widget.find('.arrow');                var $large = $widget.find('.large');                var $small = $widget.find('.small');                var config = $scope.widget.config;                // No custom options                function reload(){                    Record.query({                        id: config.dataSourceId,                        limit: 2                    }).$promise.then(function (resp) {                        resp = resp || [0];                        var det;                        if(!resp || resp.length !== 2 || ( resp.length === 2 && resp[1] === 0 ) ) {                            det = 0;                        }                        else {                            det = ((resp[0].value - resp[1].value)/resp[1].value) * 100;                        }                        if( det > 0 ){                            $arrow.removeClass('glyphicon-arrow-down');                            $arrow.addClass('glyphicon-arrow-up');                            $metricSmall.removeClass('m-green');                            $metricSmall.addClass('m-red');                        }                        else {                            $arrow.removeClass('glyphicon-arrow-up');                            $arrow.addClass('glyphicon-arrow-down');                            $metricSmall.removeClass('m-red');                            $metricSmall.addClass('m-green');                        }                        $metric.html(resp[0].value);                        det = Math.abs(det).toFixed(2).toString().split('.');                        $large.text(det[0]);                        $small.text('.' + det[1] + '%');                        $scope.updatedTime = formatDate(new Date ());                    },'json');                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply(this);                var cleanUpFuncs = [];                $scope.$on('$destroy', function(){                    if(intervalTimer) {                        clearInterval(intervalTimer);                    }                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('widgetColumn',[    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/column.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var $container = $($elem).find('.content');                var timeLine = [];                config.dataInfos = config.dataInfos || [];                var intervalTimer = null;                function reload () {                   var promises = config.dataInfos.map(function(dataInfo){                       return DataSource.get({                           id: dataInfo.id                       }).$promise.then(function(dataSource){                           return Record.query({                               id: dataSource.id,                               limit: config.limit                           }).$promise.then(function(records){                               return {                                   dataSource: dataSource,                                   records: (function(){                                       return records.map(function(record) {                                           return record;                                       } );                                   })()                               };                           });                       });                   });                    $q.all(promises).then(function (results) {                        var sortedMultiRecords = sortMultiRecords(                            (function(){                               return results.map(function(result){                                   return result.records;                               });                            })(),                            {                               formatDate: formatDate                            }                        );                       var dataSeries = results.map(function(result, idx){                           return {                               name: result.dataSource.name,                               color: defaultColors[(idx >= defaultColors.length ? (idx % defaultColors.length) : idx)],                               data: sortedMultiRecords[idx].map(                                   function(record){                                       return record.value;                                   })                           };                       });                       timeLine = (sortedMultiRecords && sortedMultiRecords.length > 0) ? (function(){                           return sortedMultiRecords[0].map(function(record){                               return record.time;                           });                       })() : [];                       dataSeries.forEach(function(seriesObj) {                           seriesObj.data.reverse();                       });                       timeLine.reverse();                       //update data                       chart.xAxis[0].setCategories(timeLine);                       if(!chart.series || chart.series.length === 0){                           chart.series = [];                           dataSeries.forEach(function(seriesObj){                               chart.addSeries(seriesObj);                           });                           chart.yAxis[0].update({                               gridLineWidth: 1                           });                           chart.redraw();                       }else{                           chart.series.forEach(function(seriesObj, idx){                               seriesObj.setData(dataSeries[idx].data);                           });                       }                        $scope.updatedTime = formatDate(new Date ());                   });                }                //draw chart                var chart = new Highcharts.Chart({                    chart: {                        renderTo: $container.get(0),                        type: 'column',                        backgroundColor: '#2b2b2b',                        events: {                            load: function(){                                reload.apply(this);                                // set up the updating of the chart each reloadInterval                                intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                            }                        }                    },                    title: {                        text: null                    },                    legend: {                        itemStyle: {                            color: 'white'                        }                    },                    xAxis: {                        categories: [],                        lineColor: 'rgb(102, 108, 103)'                    },                    yAxis: {                        title: {                            text: null                        },                        gridLineColor: 'rgb(102, 108, 103)',                        gridLineWidth: 0                    },                    tooltip: {                        headerFormat: '<span style="font-size:12px">{point.key}</span><table>',                        pointFormat: '<tr style="font-size: 10px"><td style="color:{series.color};padding:0">{series.name}: </td>' +                            '<td style="padding: 0; color: #000000"><b>{point.y}</b></td></tr>',                        footerFormat: '</table>',                        shared: true,                        useHTML: true                    },                    plotOptions: {                        column: {                            pointPadding: 0.2,                            borderWidth: 0                        }                    },                    series: []                });                function resizeWidget(){                    chart.reflow();                }                var cleanUpFuncs = [];                cleanUpFuncs.push($scope.$on('layoutchange', resizeWidget));                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chart){                            chart.destroy();                        }                    }, 5000);                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('splitRow', [    function(){        return {            restrict: 'A',            scope: {                rowCount: '=rowCount'            },            link: function($scope, $elem) {                var $row = $($elem);                function resize() {                    var parentHeight = $row.parent().height();                    $row.height(parentHeight / $scope.rowCount);                }                resize();                $(window).on('resize', resize);                $scope.$on('$destroy', function () {                    $(window).off('resize', resize);                });            }        };    }]);indexApp.directive('fitText', [    function(){        return {            restrict: 'A',            scope: {                compressor: '=compressor'            },            link: function($scope, $elem){                var compressor = $scope.compressor || 1;                var $this = $elem;                var resizer = function () {                    $this.css('font-size', $this.width() / (compressor * 10));                    $this.css('line-height', $this.css('font-size'));                };                // Call once to set.                resizer();                // Call on resize. Opera debounces their resize by default.                $(window).on('resize.fittext', resizer);                $scope.$on('fitdonut', resizer);                $scope.$on('$destroy', function(){                    $(window).off('resize.fittext', resizer);                });            }        };    }]);indexApp.directive('dashboard', [    function(){        return {            restrict: 'A',            scope: {                dashboard: '=',                widgets: '=',                layout: '='            },            templateUrl: 'public/src/include/dashboard_layout.html',            link: function($scope, $elem){            }        };    }]);