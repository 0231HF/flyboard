'use strict';var widgetTypes = [    {        type: 1,        label: '折线图'    },    {        type: 2,        label: '饼图'    },    {        type: 3,        label: '环形图'    },    {        type: 4,        label: '数字'    },    {        type: 5,        label: '柱形图'    }];var indexApp = angular.module('indexApp', [    'ngRoute',    'services',    'ngAnimate',    'ui.bootstrap']);var gridLayer = {    'rows': [        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        },        {'columns': [            {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}, {'span': 1}        ]        }    ]};//obj attribute: deep copy;  not obj attribute: copyfunction copyWidget(oldWidget, newWidget) {    angular.element.each(oldWidget, function(key){        if(key !== 'config'){            oldWidget[key] = newWidget[key];            return true;        }        //deep copy config        angular.element.each(oldWidget['config'], function(key){            if(key !== 'dataInfos'){                oldWidget['config'][key] = newWidget['config'][key];                return true;            }            oldWidget['config'].dataInfos.splice(0);            newWidget['config'].dataInfos.forEach(function(dataInfo){                oldWidget['config'].dataInfos.push(angular.copy(dataInfo));            });        });    });}indexApp.value('gridLayerConfig', {number: 12});indexApp.config(['$routeProvider',function($routeProvider){    $routeProvider.        when('/dashboards/:id?', {            templateUrl:'/public/src/index.html',            controller: 'IndexCtrl'        }).        when('/dashboards/:id/edit', {            templateUrl: '/public/src/edit_layout.html',            controller: 'editLayoutCtrl'        }).        otherwise({            redirectTo: '/dashboards'        });}]);function isScopeDestroyed(scope){    while(scope){        if(scope.$$destroyed){            return true;        }        scope = scope.$parent;    }    return false;}function range(n, initValue){    var ret = [];    for(var i=0; i<n; i++){        ret[i] = initValue !== undefined ? initValue : 0;    }    return ret;}indexApp.controller('SlideCtrl', ['$scope', '$route', '$routeParams', '$window', '$q', '$location', '$interval', '$timeout', 'Dashboard',    function($scope, $route, $routeParams, $window, $q, $location, $interval, $timeout, Dashboard) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = {};        $scope.$on('$routeChangeSuccess', function () {            //if editLayoutCtrl, no slide            if($route.current.$$route && $route.current.$$route.controller === 'editLayoutCtrl'){                $($window).off('mousemove', resetCheck);                stopCheck();            }            if ($routeParams.id) {                Dashboard.get({                    id: $routeParams.id                }).$promise.then(function (dashbaord) {                    $scope.dashboard = dashbaord;                });            } else {                $scope.dashboards.$promise.then(function (dashboards) {                    $scope.dashboard = dashboards[0] || null;                });            }        });        var SLIDE_INTERVAL_TIME = 600000;        var PHASE_DELAY_TIME = 1000 + 1500;        var PHASE_COUNT = 10;        //slide        $scope.slideMode = false;        //slide        function doSlide(){            var currentDashboardIdx = null;            $scope.dashboards.some(function (dashboard, idx) {                if (dashboard.id === $scope.dashboard.id) {                    currentDashboardIdx = idx;                    return true;                }            });            currentDashboardIdx = (currentDashboardIdx + 1) % $scope.dashboards.length;            var newUrl = '/dashboards/' + $scope.dashboards[currentDashboardIdx].id;            $location.path(newUrl);            stopPhaseTimer();            startPhaseDelayTimer();        }        // delay phase run        var phaseDelayTimer = null;        function startPhaseDelayTimer() {            stopPhaseDelayTimer();            phaseDelayTimer = $timeout(startPhaseTimer, PHASE_DELAY_TIME);        }        function stopPhaseDelayTimer() {            if (phaseDelayTimer !== null) {                $timeout.cancel(phaseDelayTimer);                phaseDelayTimer = null;            }        }        //timer for next slide        $scope.phase = 0;        // phase counter        var phaseTimer = null;        //timer for next slide        function startPhaseTimer(){            stopPhaseTimer();            $scope.phase = 0;            phaseTimer = $interval(function () {                $scope.phase += 1;            }, (SLIDE_INTERVAL_TIME - PHASE_DELAY_TIME) / PHASE_COUNT);        }        function stopPhaseTimer() {            if (phaseTimer) {                $interval.cancel(phaseTimer);                phaseTimer = null;            }            $scope.phase = -1;        }        // control dashboard slide interval        var slideTimer = null;        //check if go into auto slide Mode        function startSlide(){            stopSlide();            $scope.slideMode = true;            slideTimer = $interval(doSlide, SLIDE_INTERVAL_TIME);            doSlide();  //call once        }        function stopSlide() {            if (slideTimer) {                $interval.cancel(slideTimer);                slideTimer = null;            }            $scope.slideMode = false;        }        // check away from keyboard        var checkTimer = null;        function startCheck() {            stopCheck();            checkTimer = $timeout(startSlide, SLIDE_INTERVAL_TIME);        }        function stopCheck() {            if (checkTimer) {                $timeout.cancel(checkTimer);                checkTimer = null;            }        }        function resetCheck() {            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();            startCheck();        }        startCheck();        $($window).on('mousemove', resetCheck);        $scope.$on('$destroy', function(){            $($window).off('mousemove', resetCheck);            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();        });    }]);indexApp.controller('NavCtrl', ['$scope', '$route', '$routeParams','$q', '$location', '$window', 'Dashboard',    function($scope, $route, $routeParams, $q, $location, $window, Dashboard){        $scope.editLayoutMode = false;        $scope.dashboards = Dashboard.query();        $q.when($scope.dashboards).then(function(dashboards){            $scope.dashboards = dashboards || [];            function init(evt){                // ignore element resize event                if (evt.target !== undefined) {                    return;                }                $scope.editLayoutMode = $route.current.$$route ? $route.current.$$route.controller === 'editLayoutCtrl' : false;                var dashboardId = $routeParams.id ? $routeParams.id : (($scope.dashboards && $scope.dashboards.length > 0) ? $scope.dashboards[0].id: null);                if(dashboardId !== null){                    $scope.widgets = Dashboard.get({                        id: dashboardId                    }).$promise.then(function(dashboard){                        $scope.dashboard = dashboard;                    });                }            }            angular.element($window).bind('resize', init);            $scope.$on('$routeChangeSuccess', init);            $scope.toggleEditLayoutMode = function(){                $scope.editLayoutMode = !$scope.editLayoutMode;                var newUrl = '/dashboards/' + $scope.dashboard.id + ($scope.editLayoutMode ?  '/edit' : '');                $location.path(newUrl);            };        });    }]);indexApp.controller('IndexCtrl', ['$scope', '$window', '$routeParams', '$location', '$interval', 'Dashboard', 'Widget', '$q',    function($scope, $window, $routeParams, $location, $interval, Dashboard, Widget, $q) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = $routeParams.id ?            Dashboard.get({                id: $routeParams.id            }).$promise.then(function(dashboard){                return dashboard || null;            })            : $scope.dashboards.$promise.then(function (dashboards) {                return dashboards[0] || null;            });        $scope.widgets = $q.when($scope.dashboard).then(function (dashboard) {            if (dashboard === null) {                return [];            }            $scope.dashboard = dashboard;            if(!$scope.dashboard.config || !$scope.dashboard.config.layout){                return ;            }            $scope.widgetLayer = $scope.dashboard.config.layout.map(function(widgetLayout){                return {                    id: widgetLayout.id,                    x: widgetLayout.first_grid[0],                    y: widgetLayout.first_grid[1],                    w: widgetLayout.last_grid[1] - widgetLayout.first_grid[1] + 1,                    h: widgetLayout.last_grid[0] - widgetLayout.first_grid[0] + 1                };            });            return Widget.query({                dashboardid: dashboard.id            }).$promise.then(function(widgets){                return widgets;            });        });        $q.when($scope.widgets).then(function(widgets){            widgets = widgets || [];            $scope.widgets = widgets.reduce(function (memo, curr) {                memo[curr.id] = curr;                return memo;            }, {});        });    }]);indexApp.controller('editLayoutCtrl', ['$scope', '$window', '$routeParams', '$location', '$interval', 'Dashboard', 'Widget', '$q', 'gridLayerConfig',    function($scope, $window, $routeParams, $location, $interval, Dashboard, Widget, $q, gridLayerConfig) {        $scope.gridLayer = gridLayer;        $scope.dashboards = Dashboard.query();        $scope.addedControllers = [];        $scope.gridLayerStatus = [];        $scope.dashboard = Dashboard.get({            id: $routeParams.id        }).$promise.then(function(dashboard){            return dashboard || null;        });        function matchSameSegment(seg, cmpRow){            var ret = null;            cmpRow.some(function(cmpSeg, idx){                if(cmpSeg[0] > seg[0]){                    return true;                }                if(cmpSeg[0] === seg[0] && cmpSeg[1] === seg[1]){                    ret = idx;                    return true;                }            });            return ret;        }        // scan unused grid segmemt of each row        function scanGrids(grids){            var rowCount = grids.length;            var colCount = grids[0].length;            var ret = [];            for(var i = 0; i < rowCount; i++){                ret[i] = [];                var start = null, end = null;                for(var j = 0; j < colCount; j++){                    if(!grids[i][j] && start === null){                        start = j;                    }                    else if(grids[i][j] && start !== null){                        end = j-1;                        ret[i].push([start, end]);                        start = null;                        end = null;                    }                }                if(start !== null){                    ret[i].push([start, colCount - 1]);                }            }            return ret;        }        //split unused grid to controllers        $scope.calculateAddedControllers = function(gridLayerStatus) {            if(!gridLayerStatus || gridLayerStatus.length <= 0 || gridLayerStatus[0].length <= 0){                return [];            }            var validGridSegments = scanGrids(gridLayerStatus);            var result =[];            validGridSegments.forEach(function(row, rowIdx){                row.forEach(function(seg){                    var w = seg[1] - seg[0] + 1;                    var h = 1;  //at least 1 row                    validGridSegments.some(function(cmpRow, cmpRowIdx){                        if(cmpRowIdx <= rowIdx){                            return false;                        }                        var ret = matchSameSegment(seg, cmpRow);                        if(ret !== null){                            h = cmpRowIdx - rowIdx + 1;                            validGridSegments[cmpRowIdx].splice(ret, 1);                        }                        else {                            return true;                        }                    });                    result.push({                        id: null,                        x: rowIdx,                        y: seg[0],                        w: w,                        h: h                    });                });                validGridSegments[rowIdx] = [];            });            return result;        };        $scope.initGridLayerStatus = function(dashboardLayout){            //init grids status            var gridLayerStatus = range(12, false).map(range.bind(null, 12, false));            dashboardLayout.forEach(function(widgetLayout){                for(var i = widgetLayout.first_grid[0]; i <= widgetLayout.last_grid[0]; i++){                    for(var j = widgetLayout.first_grid[1]; j <= widgetLayout.last_grid[1]; j++){                        gridLayerStatus[i][j] = true;                    }                }            });            return gridLayerStatus;        };        $scope.widgets = $q.when($scope.dashboard).then(function (dashboard) {            if (dashboard === null) {                return [];            }            $scope.dashboard = dashboard;            return Widget.query({                dashboardid: dashboard.id            }).$promise.then(function(widgets){                return widgets;            });        });        $q.when($scope.widgets).then(function(widgets){            if(!$scope.dashboard.config || !$scope.dashboard.config.layout){                return ;            }            //init widget layer            $scope.widgetLayer = $scope.dashboard.config.layout.map(function(widgetLayout){                return {                    id: widgetLayout.id,                    x: widgetLayout.first_grid[0],                    y: widgetLayout.first_grid[1],                    w: widgetLayout.last_grid[1] - widgetLayout.first_grid[1] + 1,                    h: widgetLayout.last_grid[0] - widgetLayout.first_grid[0] + 1                };            });            //init controller layer            $scope.gridLayerStatus = $scope.initGridLayerStatus($scope.dashboard.config.layout);            $scope.addedControllers = $scope.calculateAddedControllers($scope.gridLayerStatus);            widgets = widgets || [];            $scope.widgets = widgets.reduce(function (memo, curr) {                memo[curr.id] = curr;                return memo;            }, {});        });        /**************** public funcs *******************/        function conflictTest (newController, oldController, gridLayerStatus){            if(newController.x < 0 || newController.y < 0 ||newController.x + newController.h > gridLayerConfig.number || newController.y + newController.w > gridLayerConfig.number){                return true;            }            for(var i = newController.x; i < newController.x + newController.h; i++){                for(var j = newController.y; j < newController.y + newController.w; j++){                    var gridObj = {                        x: i,                        y: j                    };                    if(!isValidGrid(gridObj, gridLayerStatus) && !isGridBelongToController(gridObj, oldController)) {                        return true;                    }                }            }            return false;        }        function resizeAll(newController, oldController, scope){            if(!$scope.dashboard.config || !$scope.dashboard.config.layout){                return ;            }            //save            $scope.dashboard.config.layout.forEach(function(widgetLayout){                if(widgetLayout.id === newController.id){                    widgetLayout.first_grid = [newController.x, newController.y];                    widgetLayout.last_grid = [newController.x + newController.h - 1, newController.y + newController.w - 1];                }            });            Dashboard.update({                id: $scope.dashboard.id            }, $scope.dashboard);            //update gridLayerStatus            for(var i = oldController.x; i < oldController.x + oldController.h; i++){                for(var j = oldController.y; j < oldController.y + oldController.w; j++){                    scope.gridLayerStatus[i][j] = false;                }            }            for(var m = newController.x; m < newController.x + newController.h; m++){                for(var n = newController.y; n < newController.y + newController.w; n++){                    scope.gridLayerStatus[m][n] = true;                }            }            angular.element.each(newController, function(key){                oldController[key] = newController[key];            });            //resize controllers            scope.addedControllers = scope.calculateAddedControllers(scope.gridLayerStatus);            //resize widgets            scope.widgetLayer.some(function(widgetLayout){                if(widgetLayout.id === oldController.id) {                    angular.element.each(oldController, function (key) {                        widgetLayout[key] = oldController[key];                    });                }            });            scope.$apply();            scope.$broadcast('widgetlayoutchange', {                id: oldController.id            });        }        /************************ resize ***********************/        //check if grids[x][y] is a valid grid        function isValidGrid(gridObj, grids) {            return grids[gridObj.x][gridObj.y] === false;        }        //check if grids[x][y] is controller's grid        function isGridBelongToController (gridObj, controller) {            var x = gridObj.x;            var y = gridObj.y;            return ( x >= controller.x && x < (controller.x + controller.h) ) && ( y >= controller.y && y < ( controller.y + controller.w ) );        }        $scope.adjustResize = function(newController, oldController) {            //if no change happen            if(newController.x === oldController.x && newController.y === oldController.y && newController.w === oldController.w && newController.h === oldController.h){                return ;            }            //if width < 1 or height < 1            if(newController.w === 0 || newController.h === 0){                return ;            }            //if conflict            if(conflictTest(newController, oldController, $scope.gridLayerStatus)) {                return;            }            resizeAll(newController, oldController, $scope);        };        /*************** drag ****************/        $scope.adjustDrag = function(newController, oldController){            //if no change happen            if(newController.x === oldController.x && newController.y === oldController.y && newController.w === oldController.w && newController.h === oldController.h){                return ;            }            if(conflictTest(newController, oldController, $scope.gridLayerStatus)){                return ;            }            else{                resizeAll(newController, oldController, $scope);            }        };        $scope.stopDrag = function(){        };        $scope.cancelLayoutEdit = function() {            var newUrl = '/dashboards/' + $scope.dashboard.id;            $location.path(newUrl);        };    }]);indexApp.controller('EditWidgetModalCtrl', ['$scope', '$q', '$modal',    function($scope, $q, $modal){        var $outerScope = $scope;        var newWidgetModalInstanceCtrl = ['$scope', '$rootScope', 'Widget', 'DataSource', 'Dashboard', '$modalInstance', 'dashboard', 'controller',            function ($scope, $rootScope, Widget, DataSource, Dashboard, $modalInstance, dashboard, controller) {                $scope.dashboard = dashboard;                $scope.widgetTypes = widgetTypes;                $scope.addedDataInfo = {};                $scope.dataSourceType = {                    single: true,                    multi: false                };                if (!controller.id) {                    $scope.widget = {                        dashboard_id: dashboard.id,                        config: {                            dataInfos: [{                            }]                        }                    };                }                else{                    $scope.widget = Widget.get({                        dashboardid: dashboard.id,                        id: controller.id                    });                }                DataSource.query().$promise.then(function (dataSources) {                    $scope.dataSources = dataSources;                    $scope.dataSourceMap = angular.copy(dataSources).reduce(function (memo, curr) {                        memo[curr.id] = curr;                        return memo;                    }, {});                });                $scope.addDataInfo = function(){                    $scope.isAddDataInfo = true;                };                $scope.deleteDataInfo = function(dataInfo){                    var idx = $scope.widget.config.dataInfos.indexOf(dataInfo);                    if(idx === -1){                        return ;                    }                    $scope.widget.config.dataInfos.splice(idx, 1);                };                $scope.addOk = function(){                    if(!$scope.addedDataInfo.id){                        return ;                    }                    $scope.widget.config.dataInfos = $scope.widget.config.dataInfos || [];                    DataSource.get({                        id: $scope.addedDataInfo.id                    }).$promise.then(function(dataSource) {                        $scope.widget.config.dataInfos.push({                            id: dataSource.id                        });                    });                    $scope.isAddDataInfo = false;                    $scope.addedDataInfo = {};                };                $scope.addCancel = function(){                    $scope.isAddDataInfo = false;                };                $scope.ok = function () {                    if($scope.dataSourceType.single) {                        $scope.widget.config.dataInfos.splice(1);                    }                    if(!controller.id) {                        Widget.save({                            dashboardid: $scope.dashboard.id                        }, $scope.widget).$promise.then(function (widget) {                            $outerScope.widgets[widget.id] = widget;                            //update dashboard                            $scope.dashboard.config = $scope.dashboard.config || {};                            $scope.dashboard.config.layout = $scope.dashboard.config.layout || [];                            $scope.dashboard.config.layout.push({                                id: widget.id,                                first_grid: [controller.x, controller.y],                                last_grid: [controller.x + controller.h - 1, controller.y + controller.w - 1]                            });                            Dashboard.update({                                id: $scope.dashboard.id                            }, $scope.dashboard);                            //update layout view                            $outerScope.widgetLayer.push({                                id: widget.id,                                x: controller.x,                                y: controller.y,                                w: controller.w,                                h: controller.h                            });                            //update grids' status                            for(var i = controller.x; i < controller.x + controller.h; i++){                                for(var j = controller.y; j < controller.y + controller.w; j++){                                    $outerScope.gridLayerStatus[i][j] = true;                                }                            }                            //delete controller from addedControllers                            var idx = $outerScope.addedControllers.indexOf(controller);                            $outerScope.addedControllers.splice(idx, 1);                            $modalInstance.close();                        });                    }                    else{                        Widget.update({                            dashboardid: $scope.dashboard.id,                            id: $scope.widget.id                        }, $scope.widget).$promise.then(function (widget) {                            //update widgets                            angular.element.each($outerScope.widgets, function(id){                                if(parseInt(id, 10) === widget.id) {                                    copyWidget($outerScope.widgets[id], widget);                                }                            });                            $rootScope.$broadcast('widgetupdate', {                                id: widget.id                            });                            $modalInstance.close();                        });                    }                };                $scope.cancel = function () {                    $modalInstance.dismiss('cancel');                };            }        ];        $scope.open = function (controller) {            var newWidgetModalInstance = $modal.open({                templateUrl: '/public/src/include/widget_edit_modal.html',                controller: newWidgetModalInstanceCtrl,                resolve: {                    dashboard: function () {                        return $scope.dashboard;                    },                    controller: function () {                        return controller;                    }                }            });        };    }]);indexApp.directive('aggregationAndFilter', [ 'Record',    function (Record){        return {            restrict: 'A',            scope: {                type: '=type',                dataSource: '=source',                dataInfo: '=info'            },            templateUrl: 'public/src/include/aggregation_directive.html',            link: function ($scope, $elem) {                var oldDataSourceId = $scope.dataInfo.id;                if(!$scope.dataInfo.dimensions || $scope.dataInfo.dimensions.length === 0) {                    $scope.dataInfo.dimensions = $scope.dataInfo.dimensions || [];                    $scope.dataSource.config.dimensions = $scope.dataSource.config.dimensions || [];                    $scope.dataSource.config.dimensions.forEach(function (dimension, idx) {                        $scope.dataInfo.dimensions[idx] = {                            key: dimension.key,                            name: dimension.name,                            value: null                        };                    });                }                $scope.dataInfo.op = $scope.type;                $scope.init = function (dataSource, idx) {                    if(oldDataSourceId !== dataSource.id) {                        $scope.dataInfo.id = dataSource.id;                        $scope.dataInfo.dimensions = $scope.dataInfo.dimensions || [];                        $scope.dataInfo.dimensions.splice(0);                        dataSource.config.dimensions.forEach(function (dimension, idx) {                            $scope.dataInfo.dimensions[idx] = {                                key: dimension.key,                                name: dimension.name,                                value: null                            };                        });                        oldDataSourceId = $scope.dataInfo.id;                    }                    return Record.query({                        id: $scope.dataSource.id,                        distinct: 'dim' + (idx+1)                    });                };            }        };    }]);indexApp.directive('eatClick', [    function () {        return {            restrict: 'A',            scope: {                tabMode: '=tabMode',                mode: '=mode'            },            link: function ($scope, $elem) {                angular.element($elem).click(function (evt) {                    evt.preventDefault();                    $scope.mode = $scope.tabMode;                });            }        };    }]);indexApp.directive('resizeable', ['gridLayerConfig',    function(gridLayerConfig){        return {            restrict: 'A',            scope: {                resizableConfig: '=',                controller: '=',                adjustResize: '='            },            link: function($scope, $elem){                function resize(){                    var newW = Math.round($(this).width() / $(this).parents('.layer').width() * gridLayerConfig.number);                    var newH = Math.round($(this).height() / $(this).parents('.layer').height() * gridLayerConfig.number);                    var newController = {                        id: $scope.controller.id,                        w: newW,                        h: newH,                        x: $scope.controller.x,                        y: $scope.controller.y                    };                    $scope.adjustResize(newController, $scope.controller);                }                function resizeStop(){                    //clear css style                    $(this).removeAttr('style');                }                $elem.resizable($scope.resizableConfig);                $elem.on('resize', resize);                $elem.on('resizestop', resizeStop);                $scope.$on('$destroy', function(){                    $elem.off('resize', resize);                    $elem.off('resizestop', resizeStop);                });            }        };    }]);indexApp.directive('draggable', ['gridLayerConfig',    function(gridLayerConfig){        return {            restrict: 'A',            scope: {                adjustDrag: '=',                stopDrag: '=',                controller: '='            },            link: function($scope, $elem){                var $dragElement = $elem.parent();                function drag() {                    var newX = Math.round($(this).offset().top / $(this).parents('.layer').height() * gridLayerConfig.number);                    var newY = Math.round($(this).offset().left / $(this).parents('.layer').width() * gridLayerConfig.number);                    var newController = {                        id: $scope.controller.id,                        w: $scope.controller.w,                        h: $scope.controller.h,                        x: newX,                        y: newY                    };                    $scope.adjustDrag(newController, $scope.controller);                }                function dragStop () {                    $scope.stopDrag();                    //clear css style                    $(this).removeAttr('style');                }                $dragElement.draggable({                    handle:'.drag-inner-wrapper',                    cursor: 'move' ,                    scroll: false                });                $dragElement.on('drag', drag);                $dragElement.on('dragstop', dragStop);                $scope.$on('$destroy', function(){                    $dragElement.off('drag', drag);                    $dragElement.off('dragstop', dragStop);                });            }        };    }]);indexApp.service('widgetUrl', function () {    return function (widget) {        var href = '/stat#?dataSourceIds=';        if(!widget){            href = '/stat';            return href;        }        href += widget.config.dataInfos.map(function(dataInfo){            return dataInfo.id;        }).join(',');        return href;    };});indexApp.directive('widgetSpline', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function (widgetUrl, $q, DataSource, Record, $timeout) {        return {            restirct: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/spline.html',            replace: true,            link: function ($scope, $elem) {                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var latestRecordId = {};                var $container = $($elem).find('.content');                config.dataInfos = config.dataInfos || [];                //request data                function requestData () {                    return config.dataInfos.map(function (dataInfo, index) {                        return DataSource.get({                            id: dataInfo.id                        }).$promise.then(function (dataSource) {                            return Record.query({                                id: dataInfo.id,                                limit: config.limit || 0                            }).$promise.then(function (resp) {                                var lineOpt = {};                                lineOpt.name = dataSource.name;                                index = index >= defaultColors.length ? (index % defaultColors.length) : index;                                lineOpt.color = defaultColors[index];                                lineOpt.data = [];                                resp = resp || [];                                latestRecordId[dataSource.name] = (!resp || resp.length === 0) ? null : resp[0].id;                                resp.reverse().forEach(function (record) {                                    lineOpt.data.push({                                        x: getTimeFromRecord(record),                                        y: record.value                                    });                                });                                return lineOpt;                            });                        });                    });                }                //draw chart                var promises = requestData();                $q.all(promises).then(function (dataSeries) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    function reload() {                        config.dataInfos.forEach(function (dataInfo, idx) {                            DataSource.get({                                id: dataInfo.id                            }).$promise.then(                                function (dataSource) {                                    Record.query({                                        id: dataInfo.id,                                        limit: config.limit || 0                                    }).$promise.then(                                        function (resp) {                                            var flag = false;                                            resp.reverse().filter(function (record) {                                                if (record.id === latestRecordId[dataSource.name]) {                                                    flag = true;                                                    return false;                                                }                                                if (flag) {                                                    chart.series[idx].addPoint([getTimeFromRecord(record), record.value], true, true);                                                }                                            });                                            latestRecordId[dataSource.name] = resp[resp.length - 1].id;                                            $scope.updatedTime = formatDate(new Date ());                                        });                                });                        });                    }                    //redraw the chart                    function redraw () {                        var chart = this;                        var promises = requestData();                        $q.all(promises).then(function (dataSeries) {                            for(var idx = chart.series.length - 1; idx >= 0; idx--){                                chart.series[idx].remove(true);                            }                            dataSeries.forEach(function(seriesObj){                               chart.addSeries(seriesObj);                            });                            chart.redraw();                        });                    }                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            backgroundColor: '#3b3b3b',                            type: 'spline',                            animation: Highcharts.svg, // don't animate in old IE                            marginRight: 15,                            marginTop: 10,                            events: {                                load: function () {                                    var series = this.series;                                    // set up the updating of the chart each reloadInterval                                    intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                                }                            }                        },                        title: {                            text: ''                        },                        xAxis: {                            type: 'datetime',                            tickPixelInterval: 150,                            lineColor: 'rgb(169, 169, 169)'                        },                        yAxis: {                            title: null,                            gridLineColor: null,                            plotLines: null,                            min: ( config.minThreshold !== undefined && config.minThreshold >= 0 ) ? config.minThreshold : null,                            max: ( config.maxThreshold !== undefined && config.maxThreshold >= 0 ) ? config.maxThreshold : null,                            startOnTick: false,                            endOnTick: false                        },                        tooltip: {                            crosshairs: true,                            shared: true                        },                        legend: {                            layout: 'vertical',                            align: 'left',                            verticalAlign: 'top',                            y: 0,                            floating: true,                            borderWidth: 0,                            itemStyle: {                                color: 'lightgray'                            }                        },                        exporting: {                            enabled: false                        },                        series: dataSeries,                        plotOptions: {                            spline: {                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    color: 'lightgray',                                    formatter: function () {                                        if (this.point.x === this.series.data[this.series.data.length - 1].x) {                                            return this.y;                                        } else {                                            return null;                                        }                                    }                                }                            }                        }                    });                    $scope.updatedTime = formatDate(new Date ());                    function resizeWidget(evt, data){                       if(data && data.id === $scope.widget.id){                           chart.reflow();                       }                    }                    function updateWidget (evt, data) {                        if(data && data.id === $scope.widget.id){                            redraw.apply(chart);                        }                    }                    var cleanUpFuncs = [];                    cleanUpFuncs.push($scope.$on('widgetlayoutchange', resizeWidget));                    cleanUpFuncs.push($scope.$on('widgetupdate', updateWidget));                    $scope.$on('$destroy', function(){                        clearInterval(intervalTimer);                        $timeout(function () {                        if(chart) {                           chart.destroy();                        }                        }, 5000);                        cleanUpFuncs.forEach(function(cleanUpFunc){                            cleanUpFunc();                        });                    });                });            }        };    }]);indexApp.directive('widgetPie', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget',                widgets: '='            },            templateUrl: 'public/src/include/widgets/pie.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $container = $($elem).find('.cf-pie');                var pId = $container.prop('id');                var config = $scope.widget.config;                config.dataInfos = config.dataInfos || [];                // Store chart information                cf_rPs[pId] = {};                //request data                var promises = config.dataInfos.map(function(dataInfo){                    return DataSource.get({                        id: dataInfo.id                    }).$promise.then(function (dataSource) {                        return Record.query({                            id: dataInfo.id,                            limit: 1                        }).$promise.then(function (resp) {                            if ((resp ? resp.length: 0) === 0) {                                return [dataSource.name, 0];                            }                            return [dataSource.name, resp[0].value];                        });                    });                });                //draw chart                $q.all(promises).then(function (data) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    function reload(){                        var promises = config.dataInfos.map(function(dataInfo){                            return DataSource.get({                                id: dataInfo.id                            }).$promise.then(function(dataSource){                                return Record.query({                                    id: dataInfo.id,                                    limit: 1                                }).$promise.then(function(resp) {                                    if ((resp ? resp.length : 0) === 0) {                                        return [dataSource.name, 0];                                    }                                    return [dataSource.name, resp[0].value];                                    }                                );                            });                        });                        $q.all(promises).then(function (result) {                            chart.series[0].setData(result);                            $scope.updatedTime = formatDate(new Date ());                        });                    }                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            plotBackgroundColor: null,                            plotBorderWidth: null,                            plotShadow: false,                            backgroundColor: 'rgba(0,0,0,0)',                            events: {                                load: function(){                                    var chart = this;                                    intervalTimer = setInterval(reload, config.reloadInterval);                                }                            }                        },                        title:{                            text: ''                        },                        tooptip: {                            pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'                        },                        plotOptions: {                            pie: {                                size: null,                                center: [null, null],                                allowPointSelect: true,                                cursor: 'pointer',                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    formatter: function () {                                        var lineWidth = Math.round($container.width()/6);                                        var string = [].slice.call(this.point.name);                                        var numberPerLine = Math.round(lineWidth/14);                                        var count = 0;                                        for(var i = 1; i < string.length; i++){                                            if( (i - count) % numberPerLine === 0){                                                string.splice(i, 0 , '<br>');                                                console.log();                                                count += 1;                                                i += 1;                                            }                                        }                                        return '<b>' + string.join('') + '</b>:' + this.point.percentage.toFixed(1) + '%' ;                                    },                                    color: 'lightgray',                                    style: {                                        color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black',                                        fontSize: '14px',                                        width: Math.round($container.width()/14) + 'px'                                    }                                }                            }                        },                        series: [{                            type: 'pie',                            name: config.name,                            data: data                        }]                    });                    $scope.updatedTime = formatDate(new Date ());                    function resizeWidget(evt, data){                        if(data && data.id === $scope.widget.id) {                            chart.reflow();                        }                    }                    function updateWidget (evt, data) {                        if(data && data.id === $scope.widget.id) {                            //reload                            reload.apply(chart);                            chart.redraw();                        }                    }                    var cleanUpFuncs = [];                    cleanUpFuncs.push($scope.$on('widgetlayoutchange', resizeWidget));                    cleanUpFuncs.push($scope.$on('widgetupdate', updateWidget));                    $scope.$on('$destroy', function() {                        clearInterval(intervalTimer);                        $timeout(function(){                            if (chart) {                                chart.destroy();                            }                        }, 5000);                        cleanUpFuncs.forEach(function(cleanUpFunc){                            cleanUpFunc();                        });                    });                });            }        };    }]);indexApp.directive('widgetDonut', [    'widgetUrl',    'Record',    '$timeout',    function(widgetUrl, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/donut.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $this = this;                var $container = $elem.find('.cf-svp');                var $metrics = $container.find('.metrics');                var $arrow = $elem.find('.change .arrow');                var $changeMetric = $elem.find('.change');                var $large = $changeMetric.find('.large');                var $small = $changeMetric.find('.small');                var config = $scope.widget.config;                $container.data('id', 'widget-' + $scope.widget.id);                var chartWrapper = rSVP($container);                //broadcast to call fitText once                $scope.$broadcast('fitdonut');                function reload(){                    var $container = $(this).find('.cf-svp');                    Record.query({                        id: config.dataInfos[0].id,                        limit: 2,                        dimensions: JSON.stringify(config.dataInfos[0].dimensions)                    }).$promise.then(function(resp){                        //aggregation according to date_time                        var latestRecordIdx = -1;                        for(var j = resp.length - 1; j >= 0; j --){                            if(latestRecordIdx !== -1 && resp[latestRecordIdx].date_time === resp[j].date_time){                                resp[j].value += resp[latestRecordIdx].value;                                resp.splice(latestRecordIdx, 1);                            }                            latestRecordIdx = j;                        }                        //update change percentage                        resp = (!resp || resp.length === 0)? [{value: null}] : resp;                        var det;                        if(!resp || resp.length !== 2 || ( resp.length === 2 && resp[1].value === 0 ) ) {                            det = 0;                        }                        else {                            det = ((resp[0].value - resp[1].value)/Math.abs(resp[1].value)) * 100;                        }                        if( det > 0 ){                            $arrow.removeClass('glyphicon-arrow-down');                            $arrow.addClass('glyphicon-arrow-up');                            $changeMetric.removeClass('m-green');                            $changeMetric.addClass('m-red');                        }                        else {                            $arrow.removeClass('glyphicon-arrow-up');                            $arrow.addClass('glyphicon-arrow-down');                            $changeMetric.removeClass('m-red');                            $changeMetric.addClass('m-green');                        }                        det = Math.abs(det).toFixed(2).toString().split('.');                        $large.text(det[0]);                        $small.text('.' + det[1] + '%');                        //update current value                        var chart = chartWrapper.chart;                        if(resp[0].value === null){                            $metrics.css('display', 'none');                        }                        else{                            config.value = resp[0].value + '';                            $metrics.css('display', '');                        }                        // Call EasyPieChart update function                        chart.update(config.value);                        // Update the data-percent so it redraws on resize properly                        $container.find('.chart').data('percent', config.value);                        // Update the UI metric                        $elem.find('.metric').html('' + config.value);                        $scope.updatedTime = formatDate(new Date ());                    });                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply($this);                function resizeWidget(evt, data){                    if(data && data.id === $scope.widget.id) {                        chartWrapper.generateChart();                    }                }                function updateWidget (evt, data) {                    if(data && data.id === $scope.widget.id) {                        reload.apply($this);                        chartWrapper.generateChart();                    }                }                var cleanUpFuncs = [];                cleanUpFuncs.push($scope.$on('widgetlayoutchange', resizeWidget));                cleanUpFuncs.push($scope.$on('widgetupdate', updateWidget));                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chartWrapper) {                            chartWrapper.destroy();                        }                    }, 5000);                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('widgetNumber', [    'widgetUrl',    '$q',    'Record',    function(widgetUrl, $q, Record){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/number.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $widget = $($elem);                var $metric = $widget.find('.metric');                var $metricSmall = $widget.find('.metric-small');                var $change = $widget.find('.change');                var $arrow = $widget.find('.arrow');                var $large = $widget.find('.large');                var $small = $widget.find('.small');                var config = $scope.widget.config;                // No custom options                function reload(){                    Record.query({                        id: config.dataInfos[0].id,                        limit: 2,                        dimensions: JSON.stringify(config.dataInfos[0].dimensions)                    }).$promise.then(function (resp) {                        //aggregation according to date_time                        var latestRecordIdx = -1;                        for(var j = resp.length - 1; j >= 0; j --){                            if(latestRecordIdx !== -1 && resp[latestRecordIdx].date_time === resp[j].date_time){                                resp[j].value += resp[latestRecordIdx].value;                                resp.splice(latestRecordIdx, 1);                            }                            latestRecordIdx = j;                        }                        resp = (!resp || resp.length === 0)? [{value: null}] : resp;                        var det;                        if(!resp || resp.length !== 2 || ( resp.length === 2 && resp[1].value === 0 ) ) {                            det = 0;                        }                        else {                            det = ((resp[0].value - resp[1].value)/Math.abs(resp[1].value)) * 100;                        }                        if( det > 0 ){                            $arrow.removeClass('glyphicon-arrow-down');                            $arrow.addClass('glyphicon-arrow-up');                            $metricSmall.removeClass('m-green');                            $metricSmall.addClass('m-red');                        }                        else {                            $arrow.removeClass('glyphicon-arrow-up');                            $arrow.addClass('glyphicon-arrow-down');                            $metricSmall.removeClass('m-red');                            $metricSmall.addClass('m-green');                        }                        $metric.html(resp[0].value);                        if(resp[0].value === null) {                            $change.css('display', 'none');                        }                        else{                            $change.css('display', '');                        }                        det = Math.abs(det).toFixed(2).toString().split('.');                        $large.text(det[0]);                        $small.text('.' + det[1] + '%');                        $scope.updatedTime = formatDate(new Date ());                    },'json');                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply(this);                function updateWidget () {                    reload.apply(this);                }                var cleanUpFuncs = [];                cleanUpFuncs.push($scope.$on('widgetupdate', updateWidget));                $scope.$on('$destroy', function(){                    if(intervalTimer) {                        clearInterval(intervalTimer);                    }                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('widgetColumn',[    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget',                widgets: '='            },            templateUrl: 'public/src/include/widgets/column.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var $container = $($elem).find('.content');                var timeLine = [];                config.dataInfos = config.dataInfos || [];                var intervalTimer = null;                function reload () {                   var promises = config.dataInfos.map(function(dataInfo){                       return DataSource.get({                           id: dataInfo.id                       }).$promise.then(function(dataSource){                           return Record.query({                               id: dataSource.id,                               limit: config.limit                           }).$promise.then(function(records){                               return {                                   dataSource: dataSource,                                   records: (function(){                                       return records.map(function(record) {                                           return record;                                       } );                                   })()                               };                           });                       });                   });                    $q.all(promises).then(function (results) {                        var sortedMultiRecords = sortMultiRecords(                            (function(){                               return results.map(function(result){                                   return result.records;                               });                            })(),                            {                               formatDate: formatDate                            }                        );                       var dataSeries = results.map(function(result, idx){                           return {                               name: result.dataSource.name,                               color: defaultColors[(idx >= defaultColors.length ? (idx % defaultColors.length) : idx)],                               data: sortedMultiRecords[idx].map(                                   function(record){                                       return record.value;                                   })                           };                       });                       timeLine = (sortedMultiRecords && sortedMultiRecords.length > 0) ? (function(){                           return sortedMultiRecords[0].map(function(record){                               return record.time;                           });                       })() : [];                       dataSeries.forEach(function(seriesObj) {                           seriesObj.data.reverse();                       });                       timeLine.reverse();                       //update data                       chart.xAxis[0].setCategories(timeLine);                       if(!chart.series || chart.series.length === 0){                           chart.series = [];                           dataSeries.forEach(function(seriesObj){                               chart.addSeries(seriesObj);                           });                           chart.yAxis[0].update({                               gridLineWidth: 1                           });                           chart.redraw();                       }else{                           chart.series.forEach(function(seriesObj, idx){                               seriesObj.setData(dataSeries[idx].data);                           });                       }                        $scope.updatedTime = formatDate(new Date ());                   });                }                //redraw the chart                function redraw () {                    var chart = this;                    for(var idx = chart.series.length - 1; idx >= 0; idx--){                        chart.series[idx].remove(true);                    }                    reload.apply(chart);                }                //draw chart                var chart = new Highcharts.Chart({                    chart: {                        renderTo: $container.get(0),                        type: 'column',                        backgroundColor: '#3b3b3b',                        marginRight: 20,                        marginTop: 30,                        events: {                            load: function(){                                reload.apply(this);                                // set up the updating of the chart each reloadInterval                                intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                            }                        }                    },                    title: {                        text: null                    },                    legend: {                        itemStyle: {                            color: 'lightgrey'                        }                    },                    xAxis: {                        categories: [],                        lineColor: 'rgb(169,169,169)'                    },                    yAxis: {                        title: {                            text: null                        },                        gridLineColor: 'rgb(169, 169, 169)',                        gridLineWidth: 0                    },                    tooltip: {                        headerFormat: '<span style="font-size:12px">{point.key}</span><table>',                        pointFormat: '<tr style="font-size: 10px"><td style="color:{series.color};padding:0">{series.name}: </td>' +                            '<td style="padding: 0; color: #000000"><b>{point.y}</b></td></tr>',                        footerFormat: '</table>',                        shared: true,                        useHTML: true                    },                    plotOptions: {                        column: {                            pointPadding: 0.2,                            borderWidth: 0                        }                    },                    series: []                });                function resizeWidget(evt, data){                    if(data && data.id === $scope.widget.id) {                        chart.reflow();                    }                }                function updateWidget (evt, data) {                    if(data && data.id === $scope.widget.id) {                        redraw.apply(chart);                    }                }                var cleanUpFuncs = [];                cleanUpFuncs.push($scope.$on('widgetlayoutchange', resizeWidget));                cleanUpFuncs.push($scope.$on('widgetupdate', updateWidget));                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chart){                            chart.destroy();                        }                    }, 5000);                    cleanUpFuncs.forEach(function(cleanUpFunc){                        cleanUpFunc();                    });                });            }        };    }]);indexApp.directive('splitRow', [    function(){        return {            restrict: 'A',            scope: {                rowCount: '=rowCount'            },            link: function($scope, $elem) {                var $row = $($elem);                function resize() {                    var parentHeight = $row.parent().height();                    $row.height(parentHeight / $scope.rowCount);                }                resize();                $(window).on('resize', resize);                $scope.$on('$destroy', function () {                    $(window).off('resize', resize);                });            }        };    }]);indexApp.directive('fitText', [    function(){        return {            restrict: 'A',            scope: {                compressor: '=compressor'            },            link: function($scope, $elem){                var compressor = $scope.compressor || 1;                var $this = $elem;                var resizer = function () {                    $this.css('font-size', $this.width() / (compressor * 10));                    $this.css('line-height', $this.css('font-size'));                };                // Call once to set.                resizer();                // Call on resize. Opera debounces their resize by default.                $(window).on('resize.fittext', resizer);                $scope.$on('fitdonut', resizer);                $scope.$on('$destroy', function(){                    $(window).off('resize.fittext', resizer);                });            }        };    }]);indexApp.directive('dashboard', [    function(){        return {            restrict: 'A',            scope: {                dashboard: '=',                widgets: '=',                widgetLayer: '='            },            templateUrl: 'public/src/include/dashboard_layout.html',            link: function($scope, $elem){            }        };    }]);indexApp.controller('DeleteWidgetCtrl', ['$scope', '$routeParams', '$q', 'Dashboard', 'Widget',    function($scope, $routeParams, $q, Dashboard, Widget){        $scope.dashboard = Dashboard.get({            id: $routeParams.id        }).$promise.then(function(dashboard){            return dashboard || null;        });        $q.when($scope.dashboard).then(function (dashboard) {            $scope.dashboard = dashboard;            $scope.deleteWidget = function(controller) {                var widgetId = controller.id;                //delete widget                Widget.delete({                    dashboardid: $scope.dashboard.id,                    id: widgetId                }).$promise.then(function(){                    if(!$scope.dashboard.config.layout){                        return ;                    }                    //delete widget info in dashboard                    $scope.dashboard.config.layout.some(function(widgetLayout, idx){                        if(widgetLayout.id === widgetId){                            $scope.dashboard.config.layout.splice(idx, 1);                            return true;                        }                    });                    Dashboard.update({                        id: $scope.dashboard.id                    }, $scope.dashboard);                    //update controllers                    $scope.widgetLayer.some(function(widgetLayout, idx){                        if(widgetLayout.id === widgetId){                            $scope.widgetLayer.splice(idx, 1);                            return true;                        }                    });                    for(var i = controller.x; i < controller.x + controller.h; i++ ){                        for(var j = controller.y; j < controller.y + controller.w; j++){                            $scope.gridLayerStatus[i][j] = false;                        }                    }                    $scope.addedControllers.splice(0);                    $scope.calculateAddedControllers($scope.gridLayerStatus).forEach(function(addedController){                        $scope.addedControllers.push(addedController);                    });                    //update widgets                    angular.element.each($scope.widgets, function(key){                        if(key === widgetId){                            delete $scope.widgets[key];                        }                    });                });            };        });    }]);