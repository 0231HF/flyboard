'use strict';var indexApp = angular.module('indexApp', [    'ngRoute',    'services',    'ngAnimate']);indexApp.config(['$routeProvider',function($routeProvider){    $routeProvider.        when('/dashboards/:id?', {            templateUrl:'/public/src/index.html',            controller: 'IndexCtrl'        }).        otherwise({            redirectTo: '/dashboards'        });}]);function isScopeDestroyed(scope){    while(scope){        if(scope.$$destroyed){            return true;        }        scope = scope.$parent;    }    return false;}indexApp.controller('SlideCtrl', ['$scope', '$routeParams', '$window', '$q', '$location', '$interval', '$timeout', 'Dashboard',    function($scope, $routeParams, $window, $q, $location, $interval, $timeout, Dashboard) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = {};        $scope.$on('$routeChangeSuccess', function () {            if ($routeParams.id) {                Dashboard.get({                    id: $routeParams.id                }).$promise.then(function (dashbaord) {                    $scope.dashboard = dashbaord;                });            } else {                $scope.dashboards.$promise.then(function (dashboards) {                    $scope.dashboard = dashboards[0] || null;                });            }        });        var SLIDE_INTERVAL_TIME = 600000;        var PHASE_DELAY_TIME = 1000 + 1500;        var PHASE_COUNT = 10;        //slide        $scope.slideMode = false;        //slide        function doSlide(){            var currentDashboardIdx = null;            $scope.dashboards.some(function (dashboard, idx) {                if (dashboard.id === $scope.dashboard.id) {                    currentDashboardIdx = idx;                    return true;                }            });            currentDashboardIdx = (currentDashboardIdx + 1) % $scope.dashboards.length;            var newUrl = '/dashboards/' + $scope.dashboards[currentDashboardIdx].id;            $location.path(newUrl);            stopPhaseTimer();            startPhaseDelayTimer();        }        // delay phase run        var phaseDelayTimer = null;        function startPhaseDelayTimer() {            stopPhaseDelayTimer();            phaseDelayTimer = $timeout(startPhaseTimer, PHASE_DELAY_TIME);        }        function stopPhaseDelayTimer() {            if (phaseDelayTimer !== null) {                $timeout.cancel(phaseDelayTimer);                phaseDelayTimer = null;            }        }        //timer for next slide        $scope.phase = 0;        // phase counter        var phaseTimer = null;        //timer for next slide        function startPhaseTimer(){            stopPhaseTimer();            $scope.phase = 0;            phaseTimer = $interval(function () {                $scope.phase += 1;            }, (SLIDE_INTERVAL_TIME - PHASE_DELAY_TIME) / PHASE_COUNT);        }        function stopPhaseTimer() {            if (phaseTimer) {                $interval.cancel(phaseTimer);                phaseTimer = null;            }            $scope.phase = -1;        }        // control dashboard slide interval        var slideTimer = null;        //check if go into auto slide Mode        function startSlide(){            stopSlide();            $scope.slideMode = true;            slideTimer = $interval(doSlide, SLIDE_INTERVAL_TIME);            doSlide();  //call once        }        function stopSlide() {            if (slideTimer) {                $interval.cancel(slideTimer);                slideTimer = null;            }            $scope.slideMode = false;        }        // check away from keyboard        var checkTimer = null;        function startCheck() {            stopCheck();            checkTimer = $timeout(startSlide, SLIDE_INTERVAL_TIME);        }        function stopCheck() {            if (checkTimer) {                $timeout.cancel(checkTimer);                checkTimer = null;            }        }        function resetCheck() {            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();            startCheck();        }        startCheck();        $($window).on('mousemove', resetCheck);        $scope.$on('$destroy', function(){            $($window).off('mousemove', resetCheck);            stopSlide();            stopCheck();            stopPhaseTimer();            stopPhaseDelayTimer();        });    }]);indexApp.controller('NavCtrl', ['$scope', '$routeParams','$q', '$window', 'Dashboard',    function($scope, $routeParams, $q, $window, Dashboard){        $scope.dashboards = Dashboard.query();        $q.when($scope.dashboards).then(function(dashboards){            $scope.dashboards = dashboards || [];            function init(){                var dashboardId = $routeParams.id ? $routeParams.id : (($scope.dashboards && $scope.dashboards.length > 0) ? $scope.dashboards[0].id: null);                if(dashboardId !== null){                    $scope.widgets = Dashboard.get({                        id: dashboardId                    }).$promise.then(function(dashboard){                        $scope.dashboard = dashboard;                    });                }            }            angular.element($window).bind('resize', init);            $scope.$on('$routeChangeSuccess', init);        });    }]);indexApp.controller('IndexCtrl', ['$scope', '$window', '$routeParams', '$location', '$interval', 'Dashboard', 'Widget', '$q',    function($scope, $window, $routeParams, $location, $interval, Dashboard, Widget, $q) {        $scope.dashboards = Dashboard.query();        $scope.dashboard = $routeParams.id ?            Dashboard.get({                id: $routeParams.id            }).$promise.then(function(dashboard){                return dashboard || null;            })            : $scope.dashboards.$promise.then(function (dashboards) {                return dashboards[0] || null;            });        $scope.widgets = $q.when($scope.dashboard).then(function (dashboard) {            if (dashboard === null) {                return [];            }            $scope.dashboard = dashboard;            return Widget.query({                dashboardid: dashboard.id            }).$promise.then(function(widgets){                return widgets;            });        });        $q.when($scope.widgets).then(function(widgets){            widgets = widgets || [];            $scope.widgets = widgets.reduce(function (memo, curr) {                memo[curr.id] = curr;                return memo;            }, {});        });    }]);indexApp.service('widgetUrl', function () {    return function (widget) {        var href = '/stat#?dataSourceIds=';        if(!widget){            href = '/stat';            return href;        }        switch(widget.type){            case 1:            case 2:            case 5:                href += widget.config.dataInfos.map(function(dataInfo){                    return dataInfo.id;                }).join(',');                break;            case 3:            case 4:                href += widget.config.dataSourceId;                break;            default:                break;        }        return href;    };});indexApp.directive('widgetSpline', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function (widgetUrl, $q, DataSource, Record, $timeout) {        return {            restirct: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/spline.html',            replace: true,            link: function ($scope, $elem) {                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var latestRecordId = {};                var $container = $($elem).find('.content');                config.dataInfos = config.dataInfos || [];                //request data                var promises = config.dataInfos.map(function (dataInfo, index) {                    return DataSource.get({                        id: dataInfo.id                    }).$promise.then(function (dataSource) {                        return Record.query({                            id: dataInfo.id,                            limit: config.limit || 0                        }).$promise.then(function (resp) {                            var lineOpt = {};                            lineOpt.name = dataSource.name;                            index = index >= defaultColors.length ? (index % defaultColors.length) : index;                            lineOpt.color = defaultColors[index];                            lineOpt.data = [];                            resp = resp || [];                            latestRecordId[dataSource.name] = resp[0].id;                            resp.reverse().forEach(function (record) {                                lineOpt.data.push({                                    x: getTimeFromRecord(record),                                    y: record.value                                });                            });                            return lineOpt;                        });                    });                });                //draw chart                $q.all(promises).then(function (dataSeries) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            backgroundColor: '#2b2b2b',                            type: 'spline',                            animation: Highcharts.svg, // don't animate in old IE                            marginRight: 10,                            events: {                                load: function () {                                    var series = this.series;                                    // set up the updating of the chart each reloadInterval                                    intervalTimer = setInterval(function () {                                        config.dataInfos.forEach(function (dataInfo, idx) {                                            DataSource.get({                                                id: dataInfo.id                                            }).$promise.then(                                                function (dataSource) {                                                    Record.query({                                                        id: dataInfo.id,                                                        limit: config.limit || 0                                                    }).$promise.then(                                                        function (resp) {                                                            var flag = false;                                                            resp.reverse().filter(function (record) {                                                                if (record.id === latestRecordId[dataSource.name]) {                                                                    flag = true;                                                                    return false;                                                                }                                                                if (flag) {                                                                    series[idx].addPoint([getTimeFromRecord(record), record.value], true, true);                                                                }                                                            });                                                            latestRecordId[dataSource.name] = resp[resp.length - 1].id;                                                            $scope.updatedTime = formatDate(new Date ());                                                        });                                                });                                        });                                    }, config.reloadInterval);                                }                            }                        },                        title: {                            text: ''                        },                        xAxis: {                            type: 'datetime',                            tickPixelInterval: 150,                            lineColor: 'rgb(102, 108, 103)'                        },                        yAxis: {                            title: null,                            gridLineColor: null,                            plotLines: null                        },                        tooltip: {                            crosshairs: true,                            shared: true                        },                        legend: {                            layout: 'vertical',                            align: 'left',                            verticalAlign: 'top',                            y: 0,                            floating: true,                            borderWidth: 0,                            itemStyle: {                                color: 'lightgray'                            }                        },                        exporting: {                            enabled: false                        },                        series: dataSeries,                        plotOptions: {                            spline: {                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    color: 'lightgray',                                    formatter: function () {                                        if (this.point.x === this.series.data[this.series.data.length - 1].x) {                                            return this.y;                                        } else {                                            return null;                                        }                                    }                                }                            }                        }                    });                    $scope.updatedTime = formatDate(new Date ());                    $scope.$on('$destroy', function(){                        clearInterval(intervalTimer);                        $timeout(function () {                        if(chart) {                            chart.destroy();                        }                        }, 5000);                    });                });            }        };    }]);indexApp.directive('widgetPie', [    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/pie.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $container = $($elem).find('.cf-pie');                var pId = $container.prop('id');                var config = $scope.widget.config;                config.dataInfos = config.dataInfos || [];                // Store chart information                cf_rPs[pId] = {};                //request data                var promises = config.dataInfos.map(function(dataInfo){                    return DataSource.get({                        id: dataInfo.id                    }).$promise.then(function (dataSource) {                        return Record.query({                            id: dataInfo.id,                            limit: 1                        }).$promise.then(function (resp) {                            if ((resp ? resp.length: 0) === 0) {                                return [dataSource.name, 0];                            }                            return [dataSource.name, resp[0].value];                        });                    });                });                //draw chart                $q.all(promises).then(function (data) {                    if(isScopeDestroyed($scope)){                        return ;                    }                    var intervalTimer = null;                    var chart = new Highcharts.Chart({                        chart: {                            renderTo: $container.get(0),                            plotBackgroundColor: null,                            plotBorderWidth: null,                            plotShadow: false,                            backgroundColor: 'rgba(0,0,0,0)',                            events: {                                load: function(){                                    var chart = this;                                    function reload(){                                        var promises = config.dataInfos.map(function(dataInfo){                                            return DataSource.get({                                                id: dataInfo.id                                            }).$promise.then(function(dataSource){                                                return Record.query({                                                    id: dataInfo.id,                                                    limit: 1                                                }).$promise.then(function(resp) {                                                    if ((resp ? resp.length : 0) === 0) {                                                        return [dataSource.name, 0];                                                    }                                                    return [dataSource.name, resp[0].value];                                                    }                                                );                                            });                                        });                                        $q.when(promises).then(function (result) {                                            chart.series[0].setData(result);                                            $scope.updatedTime = formatDate(new Date ());                                        });                                    }                                    intervalTimer = setInterval(reload, config.reloadInterval);                                }                            }                        },                        title:{                            text: ''                        },                        tooptip: {                            pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'                        },                        plotOptions: {                            pie: {                                allowPointSelect: true,                                cursor: 'pointer',                                colors: defaultColors,                                dataLabels: {                                    enabled: true,                                    format: '<b>{point.name}</b>: {point.percentage:.1f} %',                                    color: 'lightgray',                                    style: {                                        color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black',                                        fontSize: '14px'                                    }                                }                            }                        },                        series: [{                            type: 'pie',                            name: config.name,                            data: data                        }]                    });                    $scope.updatedTime = formatDate(new Date ());                    $scope.$on('$destroy', function() {                        clearInterval(intervalTimer);                        $timeout(function(){                            if (chart) {                                chart.destroy();                            }                        }, 5000);                    });                });            }        };    }]);indexApp.directive('widgetDonut', [    'widgetUrl',    'Record',    '$timeout',    function(widgetUrl, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/donut.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $container = $elem.find('.cf-svp');                var config = $scope.widget.config;                $container.data('id', 'widget-' + $scope.widget.id);                var chartWrapper = rSVP($container);                function reload(){                    var $container = $(this).find('.cf-svp');                    Record.query({                        id: config.dataSourceId,                        limit: 1                    }).$promise.then(function(records){                        var chart = chartWrapper.chart;                        config.value = records[0].value;                        // Call EasyPieChart update function                        chart.update(config.value);                        // Update the data-percent so it redraws on resize properly                        $container.find('.chart').data('percent', config.value);                        // Update the UI metric                        $elem.find('.metric').html('' + config.value);                        $scope.updatedTime = formatDate(new Date ());                    });                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply(this);                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chartWrapper) {                            chartWrapper.destroy();                        }                    }, 5000);                });            }        };    }]);indexApp.directive('widgetNumber', [    'widgetUrl',    '$q',    'Record',    function(widgetUrl, $q, Record){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/number.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var $widget = $($elem);                var $metric = $widget.find('.metric');                var $metricSmall = $widget.find('.metric-small');                var $arrow = $widget.find('.arrow');                var $large = $widget.find('.large');                var $small = $widget.find('.small');                var config = $scope.widget.config;                // No custom options                function reload(){                    Record.query({                        id: config.dataSourceId,                        limit: 2                    }).$promise.then(function (resp) {                        var det;                        if(!resp || resp.length !== 2 || ( resp.length === 2 && resp[1] === 0 ) ) {                            det = 0;                        }                        else {                            det = ((resp[0].value - resp[1].value)/resp[1].value) * 100;                        }                        $scope.updatedTime = formatDate(new Date ());                        resp = resp || [0];                        $metric.html(resp[0].value);                        if( det > 0 ){                            $arrow.removeClass('glyphicon-arrow-down');                            $arrow.addClass('glyphicon-arrow-up');                            $metricSmall.removeClass('m-green');                            $metricSmall.addClass('m-red');                        }                        else {                            $arrow.removeClass('glyphicon-arrow-up');                            $arrow.addClass('glyphicon-arrow-down');                            $metricSmall.removeClass('m-red');                            $metricSmall.addClass('m-green');                        }                        det = Math.abs(det).toFixed(2).toString().split('.');                        $large.text(det[0]);                        $small.text('.' + det[1] + '%');                        $arrow.fitText(1, {minFontSize: '50px', maxFontSize: '100px'});                        $metric.fitText(2, { minFontSize: '100px', maxFontSize: '200px'});                        $metricSmall.fitText(1.8, {minFontSize: '55px', maxFontSize: '100px'});                    },'json');                }                var intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                reload.apply(this);                $scope.$on('$destroy', function(){                    if(intervalTimer) {                        clearInterval(intervalTimer);                    }                });            }        };    }]);indexApp.directive('widgetColumn',[    'widgetUrl',    '$q',    'DataSource',    'Record',    '$timeout',    function(widgetUrl, $q, DataSource, Record, $timeout){        return {            restrict: 'A',            scope: {                widget: '=widget'            },            templateUrl: 'public/src/include/widgets/column.html',            replace: true,            link: function($scope, $elem){                $scope.widgetUrl = widgetUrl;                $scope.updatedTime = null;                var config = $scope.widget.config;                var $container = $($elem).find('.content');                var timeLine = [];                config.dataInfos = config.dataInfos || [];                var intervalTimer = null;                function reload () {                   var promises = config.dataInfos.map(function(dataInfo){                       return DataSource.get({                           id: dataInfo.id                       }).$promise.then(function(dataSource){                           return Record.query({                               id: dataSource.id,                               limit: config.limit                           }).$promise.then(function(records){                               return {                                   dataSource: dataSource,                                   records: (function(){                                       return records.map(function(record) {                                           return record;                                       } );                                   })()                               };                           });                       });                   });                    $q.all(promises).then(function (results) {                        var sortedMultiRecords = sortMultiRecords(                            (function(){                               return results.map(function(result){                                   return result.records;                               });                            })(),                            {                               formatDate: formatDate                            }                        );                       var dataSeries = results.map(function(result, idx){                           return {                               name: result.dataSource.name,                               color: defaultColors[(idx >= defaultColors.length ? (idx % defaultColors.length) : idx)],                               data: sortedMultiRecords[idx].map(                                   function(record){                                       return record.value;                                   })                           };                       });                       timeLine = (sortedMultiRecords && sortedMultiRecords.length > 0) ? (function(){                           return sortedMultiRecords[0].map(function(record){                               return record.time;                           });                       })() : [];                       dataSeries.forEach(function(seriesObj) {                           seriesObj.data.reverse();                       });                       timeLine.reverse();                       //update data                       chart.xAxis[0].setCategories(timeLine);                       if(!chart.series || chart.series.length === 0){                           chart.series = [];                           dataSeries.forEach(function(seriesObj){                               chart.addSeries(seriesObj);                           });                           chart.yAxis[0].update({                               gridLineWidth: 1                           });                           chart.redraw();                       }else{                           chart.series.forEach(function(seriesObj, idx){                               seriesObj.setData(dataSeries[idx].data);                           });                       }                        $scope.updatedTime = formatDate(new Date ());                   });                }                //draw chart                var chart = new Highcharts.Chart({                    chart: {                        renderTo: $container.get(0),                        type: 'column',                        backgroundColor: '#2b2b2b',                        events: {                            load: function(){                                reload.apply(this);                                // set up the updating of the chart each reloadInterval                                intervalTimer = setInterval(reload.bind(this), config.reloadInterval);                            }                        }                    },                    title: {                        text: null                    },                    legend: {                        itemStyle: {                            color: 'white'                        }                    },                    xAxis: {                        categories: [],                        lineColor: 'rgb(102, 108, 103)'                    },                    yAxis: {                        title: {                            text: null                        },                        gridLineColor: 'rgb(102, 108, 103)',                        gridLineWidth: 0                    },                    tooltip: {                        headerFormat: '<span style="font-size:12px">{point.key}</span><table>',                        pointFormat: '<tr style="font-size: 10px"><td style="color:{series.color};padding:0">{series.name}: </td>' +                            '<td style="padding: 0; color: #000000"><b>{point.y}</b></td></tr>',                        footerFormat: '</table>',                        shared: true,                        useHTML: true                    },                    plotOptions: {                        column: {                            pointPadding: 0.2,                            borderWidth: 0                        }                    },                    series: []                });                $scope.$on('$destroy', function(){                    clearInterval(intervalTimer);                    $timeout(function(){                        if(chart){                            chart.destroy();                        }                    }, 5000);                });            }        };    }]);indexApp.directive('splitRow', [    function(){        return {            restrict: 'A',            scope: {                rowCount: '=rowCount'            },            link: function($scope, $elem) {                var $row = $($elem);                function resize() {                    var parentHeight = $row.parent().height();                    $row.height(parentHeight / $scope.rowCount);                }                resize();                $(window).on('resize', resize);                $scope.$on('$destroy', function () {                    $(window).off('resize', resize);                });            }        };    }]);