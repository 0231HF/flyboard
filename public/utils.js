/* * variables and functions shared */'use strict';Highcharts.setOptions({    global: {        useUTC: false    }});//default colors used in widgetsvar defaultColors = [    'rgb(47,179,202)',  // 1 blue    'rgb(241, 86, 79)', // 2 red    'rgb(246,150,84)',  // 3 orange    'rgb(252,238,33)',  // 4 yellow    'rgb(124,188,30)',  // 5 green    'rgb(147,112,219)', // 6 purple    'rgb(65,105,225)',  // 7 darkblue    'rgb(240,128,128)', // 8 pink    'rgb(153,204,255)', // 9 lightblue    'rgb(51,204,153)',  // 10 grassgreen    'rgb(245,222,179)', // 11 wheat    'rgb(204,204,255)'  // 12 lightpurple];//format Time: xx年xx月xx日 xx:xx:xfunction formatTime (_date) {    function formatTimeElement(timeElement){        return (timeElement.toString().length === 1)? '0'+ timeElement: timeElement;    }    var date = new Date(_date);    return '' + date.getFullYear() + '-' + formatTimeElement(( date.getMonth() + 1 )) + '-' + formatTimeElement(date.getDate()) + '    '+ formatTimeElement(date.getHours()) + ':' + formatTimeElement(date.getMinutes()) + ':' + formatTimeElement(date.getSeconds());}//format Date: xxxxxxfunction formatDate (_date) {    function formatTimeElement(timeElement){        return (timeElement.toString().length === 1)? '0'+ timeElement: timeElement;    }    var date = new Date(_date);    return '' + date.getFullYear() + formatTimeElement((date.getMonth() + 1)) + formatTimeElement(date.getDate());}function getTimeFromRecord(record) {    return new Date(record.year, record.month - 1, record.day, record.hour, record.minute, record.second).getTime();}/** label: dataSource.name + dimensions' name */function additionalLabel(dataInfo, records) {    if (!dataInfo.dimensions || dataInfo.dimensions.length === 0 || !records || records.length === 0) {        return '';    }    var dimensionNameCombineStr = dataInfo.dimensions.map(function (dimension) {        if (dimension.value === 'sum') {            return null;        }        var value = dimension.value === 'ignore' ? records[0][dimension.key] : dimension.value;        return dimension.name + '(' + value + ')';    }).filter(function (item) {        return item !== null;    }).join('｜');    return dimensionNameCombineStr.length > 0 ? '-' + dimensionNameCombineStr : dimensionNameCombineStr;}/***** judge 2 object equal *****/function deepCompare () {  var i, l, leftChain, rightChain;  function compare2Objects (x, y) {    var p;    // remember that NaN === NaN returns false    // and isNaN(undefined) returns true    if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {         return true;    }    // Compare primitives and functions.    // Check if both arguments link to the same object.    // Especially useful on step when comparing prototypes    if (x === y) {        return true;    }    // Works in case when functions are created in constructor.    // Comparing dates is a common scenario. Another built-ins?    // We can even handle functions passed across iframes    if ((typeof x === 'function' && typeof y === 'function') ||       (x instanceof Date && y instanceof Date) ||       (x instanceof RegExp && y instanceof RegExp) ||       (x instanceof String && y instanceof String) ||       (x instanceof Number && y instanceof Number)) {        return x.toString() === y.toString();    }    // At last checking prototypes as good a we can    if (!(x instanceof Object && y instanceof Object)) {        return false;    }    if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {        return false;    }    if (x.constructor !== y.constructor) {        return false;    }    if (x.prototype !== y.prototype) {        return false;    }    // Check for infinitive linking loops    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {         return false;    }    // Quick checking of one object beeing a subset of another.    // todo: cache the structure of arguments[0] for performance    for (p in y) {        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {            return false;        }        else if (typeof y[p] !== typeof x[p]) {            return false;        }    }    for (p in x) {        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {            return false;        }        else if (typeof y[p] !== typeof x[p]) {            return false;        }        switch (typeof (x[p])) {            case 'object':            case 'function':                leftChain.push(x);                rightChain.push(y);                if (!compare2Objects (x[p], y[p])) {                    return false;                }                leftChain.pop();                rightChain.pop();                break;            default:                if (x[p] !== y[p]) {                    return false;                }                break;        }    }    return true;  }  if (arguments.length < 1) {    return true; //Die silently? Don't know how to handle such case, please help...    // throw "Need two or more arguments to compare";  }  for (i = 1, l = arguments.length; i < l; i++) {      leftChain = []; //Todo: this can be cached      rightChain = [];      if (!compare2Objects(arguments[0], arguments[i])) {          return false;      }  }  return true;}